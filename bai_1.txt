TCP
Lũy thừa - Byte Stream
Mã bài tập Hw8QGEz
Một chương trình server tại địa chỉ 172.188.19.218 hỗ trợ kết nối qua giao thức TCP tại cổng 1604 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s).
Yêu cầu xây dựng chương trình client thực hiện kết nối tới server trên sử dụng luồng byte dữ liệu (InputStream/OutputStream) để trao đổi thông tin theo thứ tự:
a. Gửi mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B20DCCN999;ABCDEF" với ABCDEF là mã bài tập đã đề cập ở trên.
b. Nhận dữ liệu từ server là một chuỗi gồm hai giá trị nguyên a, b được phân tách với nhau bằng "|"
Ex: 2|5
c. Thực hiện tìm giá trị a^b và gửi lên server
Ex: 32
d. Đóng kết nối và kết thúc
Code:
package luythua;
 
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.Socket;
 
/**
 *
 * @author Nauh
 */
public class TCPClient {
 
        public static void main(String[] args) throws IOException {
            Socket client = new Socket("172.188.19.218", 1604);
            InputStream is = client.getInputStream();
            OutputStream os = client.getOutputStream();
 
            //a. gui msv
            String msv = "B21DCCN404;Hw8QGEz";
        os.write(msv.getBytes());
            os.flush();
 
            //b.nhan du lieu a|b
            byte[] buffer = new byte[1024];
        is.read(buffer);
 
            String res = new String(buffer);
        System.out.println("Nhận được từ server:" + res);
 
             //c. Tính lũy thừa
            String[] numbers = res.trim().split("\\|");
            int a = Integer.parseInt(numbers[0]);
            int b = Integer.parseInt(numbers[1]);
            int result = (int) Math.pow(a, b);
        System.out.println(result);
            // Gửi kết quả lên server
        os.write((result + "").getBytes());
 
            //d. dong ket noi
            is.close();
            os.close();
        client.close();
        }
}
 
Tên miền đúng - Character Stream
Mã bài tập IBY9oDr
Một chương trình server tại địa chỉ 172.188.19.218 cho phép kết nối qua giao thức TCP tại cổng 1606 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s).
Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng byte (BufferedWriter/BufferedReader) theo kịch bản sau:
a. Gửi một chuỗi gồm mã sinh viên và mã câu hỏi với định dạng "MaSV;MaCauhoi". Ví dụ: "B20DCCN999;ABCDEF" với ABCDEF là mã bài tập đã đề cập ở trên.
b. Nhận một chuỗi ngẫu nhiên là danh sách các một số tên miền từ server
Ví dụ: giHgWHwkLf0Rd0.io, I7jpjuRw13D.io, wXf6GP3KP.vn, MdpIzhxDVtTFTF.edu, TUHuMfn25chmw.vn, HHjE9.com, 4hJld2m2yiweto.vn, y2L4SQwH.vn, s2aUrZGdzS.com, 4hXfJe9giAA.edu
c. Tìm kiếm các tên miền .edu và gửi lên server
Ví dụ: MdpIzhxDVtTFTF.edu, 4hXfJe9giAA.edu
d. Đóng kết nối và kết thúc chương trình.
Code:
 
package ten_mien_dung;
 
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.util.ArrayList;
 
/**
 *
 * @author Nauh
 */
public class TCPClient {
 
        public static void main(String[] args) throws IOException {
            Socket client = new Socket("172.188.19.218", 1606);
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
            BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));
            
            //a. gui msv
            String msv = "B21DCCN404;IBY9oDr\n";
        writer.write(msv);
        writer.flush();
            
            //b. nhan chuoi
            String s = reader.readLine();
        System.out.println(s);
            
            //c. tim .edu
            String[] domains = s.split(", ");
        ArrayList<String> list = new ArrayList<>();
            
            for(String iString: domains){
            if(iString.substring(iString.length()-4).equals(".edu")) list.add(iString);
            }
            String res = "";
            for(int i=0;i<list.size()-1;i++){
            res+=list.get(i) + ", ";
            }
        res+=list.get(list.size()-1);
        System.out.println(res);
        writer.write(res);
            //d. dong ket noi
        writer.close();
        reader.close();
        client.close();
 
 
        }
}
 
UCLN, BCNN, tổng, tích - Data Stream
[Mã câu hỏi (qCode): gCIfYYzg].  Một chương trình máy chủ cho phép kết nối qua TCP tại cổng 2207 (hỗ trợ thời gian liên lạc tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng chương trình client tương tác với server trên bằng các byte stream (DataInputStream/DataOutputStream) để trao đổi thông tin theo trình tự sau:
a. Gửi một chuỗi chứa mã sinh viên và mã câu hỏi ở định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;B1F1FDCD"
b. Nhận hai số nguyên a và b tương ứng từ máy chủ
c. Tính ước chung lớn nhất, bội chung nhỏ nhất, tổng, tích. Gửi từng giá trị số nguyên theo thứ tự trên đến máy chủ.
d. Đóng kết nối và kết thúc chương trình.
Code:
package TCP;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class UclnBcnnTongTich {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2207);
        DataInputStream dis = new DataInputStream(client.getInputStream());
        DataOutputStream dos = new DataOutputStream(client.getOutputStream());
        
        String msv = "B21DCCN096;gCIfYYzg";
        dos.writeUTF(msv);
        
        int a = dis.readInt();
        int b = dis.readInt();
        System.out.print(a + " " + b);
        System.out.println();
        
        int ucln = gcd(a, b);
        int bcnn = a * b / ucln;
        int tong = a + b;
        int tich = a * b;
        
        dos.writeInt(ucln);
        dos.writeInt(bcnn);
        dos.writeInt(tong);
        dos.writeInt(tich);
        
        dis.close();
        dos.close();
        client.close();
    }


    private static int gcd(int a, int b) {
        if (b == 0) return a;
        else return gcd(b, a % b);
    }
}




X - Bộ ba số
Mã bài tập: K3J9hR7
Một chương trình server tại địa chỉ localhost hỗ trợ kết nối qua giao thức TCP tại cổng 1234 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s).
Yêu cầu xây dựng chương trình client thực hiện kết nối tới server trên sử dụng luồng byte dữ liệu (InputStream/OutputStream) để trao đổi thông tin theo thứ tự:
1. Gửi mã sinh viên và mã câu hỏi:
 Gửi chuỗi "studentCode;qCode" theo định dạng:
Ví dụ: "B18DCCN250;701" với 701 là mã bài tập đã đề cập ở trên.
2. Nhận dữ liệu từ server:
 Server sẽ gửi lại một chuỗi gồm các số nguyên, được phân tách bằng dấu phẩy (,). Ví dụ: "1,3,5,8,13,21".
3. Xử lý dữ liệu:
   * Tìm ba số nguyên từ chuỗi nhận được, sao cho ba số đó thỏa mãn điều kiện:
c - b = a, trong đó a, b, c là ba số nguyên trong danh sách và a < b < c.
   * Gửi ba số tìm được lên server theo định dạng "a,b,c".
      4. Đóng kết nối và kết thúc chương trình.
Code:
package bo_ba_so;
 
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;
 
/**
 *
 * @author Nauh
 */
public class TCPClient {
   public static void main(String[] args) throws IOException {
            Socket client =  new Socket("localhost", 1234);
            InputStream is = client.getInputStream();
            OutputStream os = client.getOutputStream();
            
            String msv = "B21DCCN404;K3J9hR7";
        os.write(msv.getBytes());
            os.flush();
            
            byte[] rc = new byte[65536];
            is.read(rc);
            String s = new String(rc).trim();
        System.out.println(s);
        ArrayList<Integer> list = new ArrayList<>();
        StringTokenizer tokenizer = new StringTokenizer(s, ",");
        while(tokenizer.hasMoreTokens()) {
            list.add(Integer.parseInt(tokenizer.nextToken()));
            }
            String res = "";
            int min = 9999;
        Collections.sort(list);
            for(int i = list.size()-1;i>0;i--) {
                for(int j=i-1;j>=0;j--) {
                    int a = list.get(i) -  list.get(j);
                if(list.contains(a) && a < min) {
                    min = a;
                    res = "";
                    res += a + "," + list.get(j) + "," + list.get(i);
                    }
                }
            }
        System.out.println(res);
        os.write(res.getBytes());
            os.flush();
            
            is.close();
            os.close();
        client.close();
        }
 
}
 
Tổng hiệu tích - Data Stream
Mã bài tập VmMOcTU
Một chương trình server được triển khai tại địa chỉ 172.188.19.218 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s).
Yêu cầu xây dựng chương trình Client thực hiện kết nối tới server tại cổng 1605, sử dụng luồng byte dữ liệu (DatalnputStream/DataOutputStream) để trao đổi thông tin theo thứ tự:
﻿﻿﻿a. Gửi chuỗi là mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B20DCCN999;ABCDEF" với ABCDEF là mã bài tập đã đê cập ở trên.
﻿﻿﻿b. Nhận lần lượt hai số nguyên a và b từ server
﻿﻿﻿c. Thực hiện tính toán tổng, hiệu, tích và gửi lần lượt từng giá trị theo đúng thứ tự trên lên server
﻿﻿﻿d. Đóng kết nối và kết thúc
Code:
 
package tong_hieu_tich;
 
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
 
/**
 *
 * @author Nauh
 */
public class TCPClient {
   public static void main(String[] args) throws IOException {
            Socket client = new Socket("172.188.19.218", 1605);
        DataInputStream dis = new DataInputStream(client.getInputStream());
        DataOutputStream dos = new DataOutputStream(client.getOutputStream());
            
            String msv = "B21DCCN404;oQXy8rY";
        dos.writeUTF(msv);
            dos.flush();
            
            int a = dis.readInt();
            int b = dis.readInt();
        System.out.println(a);
        System.out.println(b);
            
            
            int sum = a + b;
            int sub = a - b;
            int mul = a * b;
            
        dos.writeInt(sum);
        dos.writeInt(sub);
        dos.writeInt(mul);
            dos.flush();
            
        System.out.println(sum);
        System.out.println(sub);
        System.out.println(mul);
            
            dis.close();
            dos.close();
        client.close();
            
        }
}


X - Khoảng cách nhỏ nhất của các phần tử nằm trong chuỗi - Byte Stream
[Mã câu hỏi (qCode): E4Hrktfr].  Một chương trình server hỗ trợ kết nối qua giao thức TCP tại cổng 2206 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu xây dựng chương trình client thực hiện kết nối tới server trên sử dụng luồng byte dữ liệu (InputStream/OutputStream) để trao đổi thông tin theo thứ tự: 
a.        Gửi mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B16DCCN999;FF49DC02"
b.        Nhận dữ liệu từ server là một chuỗi các giá trị số nguyên được phân tách nhau bởi ký tự ","
Ex: 1,3,9,19,33,20
c.        Thực hiện tìm giá trị khoảng cách nhỏ nhất của các phần tử nằm trong chuỗi và hai giá trị lớn nhất tạo nên khoảng cách đó. Gửi lên server chuỗi gồm "khoảng cách nhỏ nhất, số thứ nhất, số thứ hai". Ex: 1,19,20
d.        Đóng kết nối và kết thúc


Code:




package TCP;


import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


/**
 *
 * @author Nauh
 */
public class KhoangCachNhoNhat {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2206);
        InputStream is = client.getInputStream();
        OutputStream os = client.getOutputStream();
        
        String msv = "B21DCCN290;E4Hrktfr";
        os.write(msv.getBytes());
        
        byte[] buffer = new byte[1024];
        is.read(buffer);
        String s = new String(buffer).trim();
        System.out.println(s);
        String[] strings = s.split(",");
        
        List<Integer> list = new ArrayList<>();
        for(String number : strings) {
            list.add(Integer.parseInt(number));
        }
        Collections.sort(list);
        int distance = Integer.MAX_VALUE;
        int number1 = 0, number2 = 0;
        for(int i = 0; i< list.size() - 1; i++) {
            if (list.get(i + 1) - list.get(i) < distance) {
                distance = list.get(i + 1) - list.get(i);
                number1 = list.get(i);
                number2 = list.get(i + 1);
            }
        }
        String res = distance + "," + number1 + "," + number2;
        System.out.println(res);
        os.write(res.getBytes());
        os.flush();
        
        is.close();
        os.close();
        client.close();
    }
}
Liệt kê các ký tự xuất hiện nhiều hơn một lần - Character Stream
[Mã câu hỏi (qCode): gTOkaIMA].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2208 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng byte (BufferedWriter/BufferedReader) theo kịch bản sau: 
a.        Gửi một chuỗi gồm mã sinh viên và mã câu hỏi với định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;BAA62945"
b.        Nhận một chuỗi ngẫu nhiên từ server
Ví dụ: dgUOo ch2k22ldsOo
c.        Liệt kê các ký tự (là chữ hoặc số) xuất hiện nhiều hơn một lần trong chuỗi và số lần xuất hiện của chúng và gửi lên server
Ví dụ: d:2,O:2,o:2,2:3,
d.        Đóng kết nối và kết thúc chương trình.


Code:
 
package TCP;
 
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
 
/**
 *
 * @author Nauh
 */
public class LietKeCacKyTuXuatHienNhieuHon1Lan {
        public static void main(String[] args) throws IOException {
            Socket client = new Socket("203.162.10.109", 2208);
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
            BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
            
            String msv = "B21DCCN404;gTOkaIMA";
            bw.write(msv);
            bw.newLine();
            bw.flush();
            
            String s = br.readLine();
        System.out.println(s);
            
        Map<Character, Integer> map = new LinkedHashMap<>();
            for(char i : s.toCharArray()) {
            if(Character.isLetterOrDigit(i))
                map.put(i, map.getOrDefault(i, 0) + 1);
            }
            
            StringBuilder res = new StringBuilder();
        for(Map.Entry<Character, Integer> entry : map.entrySet()) {
            if(entry.getValue() > 1) {
                res.append(entry.getKey()).append(":").append(entry.getValue()).append(",");
                }
            }            
        System.out.println(res);
        bw.write(res.toString());
            bw.flush();
            
            br.close();
            bw.close();
        client.close();
        }
}
 
Loại bỏ nguyên âm - Character Stream
Mã bài tập RG6iqBz
Một chương trình server tại địa chỉ 172.188.19.218 cho phép kết nối qua giao thức TCP tại cổng 1606 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s).
Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng byte (BufferedWriter/BufferedReader) theo kịch bản sau:
a. Gửi chuỗi là mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B20DCCN999;ABCDEF" với ABCDEF là mã bài tập đã đề cập ở trên.
b. Nhận một chuỗi từ server (Chỉ chứa kí tự thường)
c. Thực hiện loại bỏ các nguyên âm trong chuỗi và gửi kết quả lên server
d. Đóng kết nối và kết thúc.
Code:
 
 
package loai_bo_nguyen_am;
 
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
 
public class TCPClient {
        public static void main(String[] args) throws IOException {
            
                // Tạo kết nối tới server
                Socket client = new Socket("172.188.19.218", 1606);
            BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
                
                // Gửi mã sinh viên và mã bài tập
                String msv = "B21DCCN031;ST87DL8\n";
            writer.write(msv);
            //writer.newLine();  // Gửi xuống dòng
            writer.flush();
                
                // Nhận chuỗi từ server
                String s = reader.readLine();
            System.out.println(s);
                
                // Loại bỏ nguyên âm (cả chữ hoa và chữ thường)
                String res = s.replaceAll("[aeiou]", "");
                
                // Gửi chuỗi đã loại bỏ nguyên âm
            writer.write(res);
            //writer.newLine();  // Gửi xuống dòng để kết thúc
            writer.flush();
            System.out.println(res);
                
                // Đóng kết nối
            reader.close();
            writer.close();
            client.close();
           
        }
}
Tổng các số nguyên trong chuỗi - Byte Stream
[Mã câu hỏi (qCode): MkzcAL43].  Một chương trình server hỗ trợ kết nối qua giao thức TCP tại cổng 2206 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). 
Yêu cầu xây dựng chương trình client thực hiện kết nối tới server trên sử dụng luồng byte dữ liệu (InputStream/OutputStream) để trao đổi thông tin theo thứ tự: 
a.        Gửi mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B16DCCN999;C64967DD"
b.        Nhận dữ liệu từ server là một chuỗi gồm các giá trị nguyên được phân tách với nhau bằng  "|"
Ex: 2|5|9|11
c.        Thực hiện tìm giá trị tổng của các số nguyên trong chuỗi và gửi lên server
Ex: 27
d.        Đóng kết nối và kết thúc
Code:
package TCP;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class TongCacSo {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2206);
        InputStream is = client.getInputStream();
        OutputStream os = client.getOutputStream();
        
        String msv = "B21DCCN269;rGIwsiw8";
        os.write(msv.getBytes());
        os.flush();
        
        byte[] buffer = new byte[1024];
        is.read(buffer);
        
        String s = new String(buffer);
        System.out.println(s);
        
        String[] list = s.trim().split("\\|");
        int sum = 0;
        for(String iString: list) {
            sum += Integer.parseInt(iString);
        }
        os.write((sum + "").getBytes());
        os.flush();
        
        System.out.println(sum);
        
        is.close();
        os.close();
        client.close();
    }
}




 
Lật xâu - Data Stream
Mã bài tập IZ1Dbgq
Một chương trình server được triển khai tại địa chỉ 172.188.19.218
(hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s), yêu cầu xây dựng chương trình Client
thực hiện kết nối tới server tại cổng 1605, sử dụng luồng byte dữ liệu (DataInputStream/DataOutputStream)
để trao đổi thông tin theo thứ tự:
a. Gửi chuỗi là mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B20DCCN999;ABCDEF" với ABCDEF là mã bài tập đã đề cập ở trên.
b. Nhận một chuỗi từ server
c. Thực hiện đảo ngược lại chuỗi và gửi lên server
d. Đóng kết nối và kết thúc
 
Code:
 
package lat_xau;
 
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
 
/**
 *
 * @author Nauh
 */
public class TCPClient {
        public static void main(String[] args) throws IOException {
            Socket client = new Socket("172.188.19.218", 1605);
        DataInputStream dis = new DataInputStream(client.getInputStream());
        DataOutputStream dos = new DataOutputStream(client.getOutputStream());
            
            String msv = "B21DCCN268;IZ1Dbgq";
        dos.writeUTF(msv);
            dos.flush();
            
            String s = dis.readUTF();
        System.out.println(s);
            
            StringBuilder sb = new StringBuilder(s);
            StringBuilder res = sb.reverse();
        System.out.println(res);
        dos.writeUTF(res.toString());
            
            dis.close();
            dos.close();
        client.close();
        }
}
 
Sắp xếp tăng dần chẵn lẻ - Byte Stream
[Mã câu hỏi (qCode): K67qseb3].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2206 (thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác tới server ở trên sử dụng các luồng byte (InputStream/OutputStream) để trao đổi thông tin theo thứ tự:


a. Gửi mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B16DCCN999;A63D9404".


b. Nhận dữ liệu từ server là một chuỗi các số nguyên được sắp xếp ngẫu nhiên, các số được phân tách nhau bởi ký tự ",". Ví dụ: "2,15,4,3,6,8,10,7,1".


c. Sắp xếp tăng dần các giá trị chẵn và sau đó tăng dần các giá trị lẻ trong dãy số. Ví dụ: "[2, 4, 6, 8, 10];[1, 3, 7, 15]". Gửi chuỗi được sắp xếp này lên server.


d. Đóng kết nối và kết thúc chương trình.
Code:
 


package TCP;


import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


/**
 *
 * @author Nauh
 */
public class SapXepChanLe {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2206);
        InputStream is = client.getInputStream();
        OutputStream os = client.getOutputStream();
        
        String msv = "B21DCCN680;K67qseb3";
        os.write(msv.getBytes());
        
        byte[] buffer = new byte[1024];
        is.read(buffer);
        String s = new String(buffer);
        System.out.println(s);
        
        List<Integer> evens = new ArrayList<>();
        List<Integer> odds = new ArrayList<>();
        String[] strings = s.trim().split(",");
        for (String i : strings) {
            int number = Integer.parseInt(i);
            if (number % 2 == 0) evens.add(number);
            else odds.add(number);
        }
        Collections.sort(evens);
        Collections.sort(odds);
        
        String res = evens + ";"  + odds;
        os.write(res.getBytes());
        
        is.close();
        os.close();
        client.close();
    }
}
Tách thành 2 chuỗi - Character Stream
[Mã câu hỏi (qCode): VdLsbmSC].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2208 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client thực hiện kết nối tới server và sử dụng luồng ký tự (BufferedWriter/BufferedReader) để trao đổi thông tin theo kịch bản
a.        Gửi một chuỗi gồm mã sinh viên và mã câu hỏi với định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;5E263AE1"
b.        Nhận một chuỗi ngẫu nhiên từ server
c.        Tách chuỗi đã nhận thành 2 chuỗi và gửi lần lượt theo thứ tự lên server
           i.        Chuỗi thứ nhất gồm các ký tự và số (loại bỏ các ký tự đặc biệt)
          ii.        Chuỗi thứ hai gồm các ký tự đặc biệt
d.        Đóng kết nối và kết thúc chương trình


Code:


package TCP;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class TachThanh2Chuoi {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2208);
        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
        
        String msv = "B21DCCN656;VdLsbmSC";
        bw.write(msv);
        bw.newLine();
        bw.flush();
        
        String s = br.readLine();
        System.out.println(s);
        String s1 = "", s2 = "";
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) s1 += c;
            else s2 += c;
        }
        
        bw.write(s1);
        bw.newLine();
        bw.flush();
        bw.write(s2);
        bw.flush();
        
        br.close();
        bw.close();
        client.close();
    }
}






Loại bỏ ký tự đặc biệt, số, ký tự trùng và giữ nguyên thứ tự xuất hiện của ký tự - Character Stream
[Mã câu hỏi (qCode): RoSBKjvc].  [Loại bỏ ký tự đặc biệt, trùng và giữ nguyên thứ tự xuất hiện] Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2208 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác tới server sử dụng các luồng ký tự (BufferedReader/BufferedWriter) theo kịch bản dưới đây:
a.        Gửi một chuỗi gồm mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;7D6265E3"
b.        Nhận một chuỗi ngẫu nhiên từ server
c.        Loại bỏ ký tự đặc biệt, số, ký tự trùng và giữ nguyên thứ tự xuất hiện của ký tự. Gửi chuỗi đã được xử lý lên server.
d.        Đóng kết nối và kết thúc chương trình
Code:


package TCP;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.util.LinkedHashSet;
import java.util.Set;


/**
 *
 * @author Nauh
 */
public class LoaiBoKyTuDacBiet {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2208);
        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
        
        String msv = "B21DCCN703;RoSBKjvc\n";
        bw.write(msv);
        bw.flush();
        
        String s = br.readLine();
        System.out.println(s);
        
        Set<Character> set = new LinkedHashSet<>();
        for (char c : s.toCharArray()) {
            if (Character.isLetter(c)) {
                set.add(c);
            }
        }
        String res = "";
        for (Character c : set) {
            res += c;
        }
        
        bw.write(res);
        bw.flush();
        
        br.close();
        bw.close();
        client.close();
    }
}




 


Xóa chuỗi
Một chương trình Server được triển khai tại địa chỉ 203.162.10.109 hỗ trợ kết nối qua giao thức TCP tại cổng 2208 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s).
Yêu cầu xây dựng chương trình Client thực hiện kết nối tới server trên, sử dụng các luồng ký tự dữ liệu (BufferedReader/BufferedWriter) để trao đổi thông tin theo thứ tự:
Chi tiết yêu cầu:
      1. Client gửi mã sinh viên và mã bài tập theo định dạng "studentCode;qCode". Ví dụ: "B20DCCN999;C916".
      2. Server gửi về hai chuỗi phản hồi:
      * Chuỗi 1: Một đoạn văn bản chứa các ký tự chữ cái và số.
      * Chuỗi 2: Một chuỗi ký tự đặc biệt hoặc ký tự phân tách.
Ví dụ: response1 = "hello*world123"; response2 = "*"
      3. Client thực hiện tách và loại bỏ tất cả các ký tự phân tách (chuỗi 2) khỏi chuỗi văn bản (chuỗi 1) và gửi lại kết quả cho Server.
      * Ví dụ: response1 = "hello*world123", response2 = "*", kết quả sau khi loại bỏ sẽ là "helloworld123".
      4. Đóng kết nối và kết thúc chương trình.
 
Code:
 
package xoa_chuoi;
 
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.util.StringTokenizer;
 
/**
 *
 * @author Nauh
 */
public class TCPClient {
        public static void main(String[] args) throws IOException {
            Socket client = new Socket("localhost", 2208);
            BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
            
            String msv = "B21DCCN404";
            bw.write(msv);
            bw.newLine();
            bw.flush();
            
            String s1 = br.readLine();
            String s2 = br.readLine();
        System.out.println(s1);
        System.out.println(s2);
        StringTokenizer token = new StringTokenizer(s1, s2);
            String res = "";
        while(token.hasMoreTokens()){
                res += token.nextToken();
            }
        System.out.println(res);
            bw.write(res);
            bw.flush();
            
            br.close();
            bw.close();
        client.close();
        }
} 
Xác suất tung xúc sắc - Data Stream
[Mã câu hỏi (qCode): xv5BcBqG].  Một chương trình servercho phép kết nối qua TCP tại cổng 2207 (hỗ trợ thời gian liên lạc tối đa cho mỗi yêu cầu là 5 giây). Yêu cầu là xây dựng chương trình client tương tác với server bằng các byte stream (DataInputStream/DataOutputStream) để trao đổi thông tin theo trình tự sau:
a. Gửi một chuỗi chứa mã sinh viên và mã câu hỏi ở định dạng "studentCode;qCode". Ví dụ: "B10DCCN000;0D135D6A".
b. Nhận từ server một số nguyên n, là số lần tung xúc xắc. Ví dụ: Nếu bạn nhận được n = 21 từ máy chủ, có nghĩa bạn sẽ nhận giá trị tung xúc xắc 21 lần.
b. Nhận từ server các giá trị sau mỗi lần tung xúc xắc. Ví dụ: Server gửi lần lượt 21 giá trị là 1,6,4,4,4,3,2,6,3,4,5,4,5,2,4,5,4,6,1,5,5
c. Tính xác suất xuất hiện của các giá trị [1,2,3,4,5,6] khi tung xúc sắc và gửi lần lượt xác suất này (dưới dạng float) lên server theo đúng thứ tự. Ví dụ gửi lên server lần lượt 6 giá trị là 0.0952381, 0.0952381, 0.0952381, 0.33333334, 0.232209524, 0.14285715
d. Đóng kết nối và kết thúc chương trình.
Code:
package TCP;


import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class XacSuatTungXucSac {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2207);
        DataInputStream dis = new DataInputStream(client.getInputStream());
        DataOutputStream dos = new DataOutputStream(client.getOutputStream());
        
        String msv = "B21DCCN344;xv5BcBqG";
        dos.writeUTF(msv);
        dos.flush();
        
        int n = dis.readInt();
        System.out.println(n);
        int[] diceResults = new int[n];
        for (int i = 0; i < n; i++) {
            diceResults[i] = dis.readInt();
            System.out.print(diceResults[i] + " ");
        }
        System.out.println();
        
        float[] probabilities = solve(diceResults, n);
        for (int i = 0; i < 6; i++) {
            dos.writeFloat(probabilities[i]);
        }
        
        dis.close();
        dos.close();
        client.close();
    }


    private static float[] solve(int[] diceResults, int n) {
        int[] count = new int[6];
        for (int i : diceResults) {
            count[i - 1]++;
        }
        
        float[] probabilities = new float[6];
        for (int i = 0; i < 6; i++) {
            probabilities[i] = (float) count[i] / n;
        }
        return probabilities;
    }
}
Tính tổng, trung bình cộng, phương sai - Data Stream
[Mã câu hỏi (qCode): AmJldrO1].  Một chương trình server cho phép kết nối qua TCP tại cổng 2207 (hỗ trợ thời gian liên lạc tối đa cho mỗi yêu cầu là 5 giây). Yêu cầu là xây dựng chương trình client tương tác với server bằng các byte stream (DataInputStream/DataOutputStream) để trao đổi thông tin theo trình tự sau:
 
a. Gửi một chuỗi chứa mã sinh viên và mã câu hỏi ở định dạng "studentCode;qCode". Ví dụ: "B10DCCN000;A1B2C3D4".
 
b. Nhận từ server một mảng chứa n số nguyên, với n được gửi từ máy chủ. Ví dụ: Server gửi mảng [5, 9, 3, 6, 8].
 
c. Tính tổng, trung bình cộng, và phương sai của mảng. Gửi kết quả lần lượt lên server dưới dạng số nguyên và float. Ví dụ, gửi lên lần lượt: 31, 6.2, 4.5599995.
 
d. Đóng kết nối và kết thúc chương trình.
Code:
 
package TCP;
 
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
 
/**
 *
 * @author Nauh
 */
public class Tong_Tbc_PhuongSai {
        public static void main(String[] args) throws IOException {
            Socket client = new Socket("203.162.10.109", 2207);
        DataInputStream dis = new DataInputStream(client.getInputStream());
        DataOutputStream dos = new DataOutputStream(client.getOutputStream());
            
            String msv = "B21DCCN404;AmJldrO1";
        dos.writeUTF(msv);
            
            int n = dis.readInt();
        System.out.println(n);
            
            int[] numbers = new int[n];
            for(int i = 0; i < n; i++) {
                numbers[i] = dis.readInt();
            System.out.print(numbers[i] + " ");
            }
        System.out.println();
            
            int sum = 0;
            for(int number : numbers) {
                sum += number;
            }
        System.out.println(sum);
            
            float tbc = (float) sum / n;
        System.out.println(tbc);
            
            float phuongSai = 0;
            for(int number: numbers) {
                phuongSai += Math.pow((number - tbc), 2);
            }
            phuongSai /= n;
        System.out.println(phuongSai);
            
        dos.writeInt(sum);
        dos.writeFloat(tbc);
        dos.writeFloat(phuongSai);
            
            dis.close();
            dos.close();
        client.close();
        }
}
Cập nhật giá trị giảm giá - Object Stream
[Mã câu hỏi (qCode): qQAgKMad].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2209 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5 giây). Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng đối tượng (ObjectOutputStream/ObjectInputStream) theo kịch bản dưới đây:


Biết lớp TCP.Product gồm các thuộc tính (id int, name String, price double, int discount) và private static final long serialVersionUID = 20231107;


a. Gửi đối tượng là một chuỗi gồm mã sinh viên và mã câu hỏi với định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;1E08CA31"


b. Nhận một đối tượng là thể hiện của lớp TCP.Product từ server.


c. Tính toán giá trị giảm giá theo price theo nguyên tắc: Giá trị giảm giá (discount) bằng tổng các chữ số trong phần nguyên của giá sản phẩm (price). Thực hiện gán giá trị cho thuộc tính discount và gửi lên đối tượng nhận được lên server.


d. Đóng kết nối và kết thúc chương trình.


Code:


package TCP;


import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class CapNhatGiaTriKhuyenMai {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Socket client = new Socket("203.162.10.109", 2209);
        ObjectInputStream ois = new ObjectInputStream(client.getInputStream());
        ObjectOutputStream oos = new ObjectOutputStream(client.getOutputStream());
        
        String msv = "B21DCCN290;qQAgKMad";
        oos.writeObject(msv);
        
        Product product = (Product) ois.readObject();
        System.out.println(product);
        
        int priceInt = (int) product.getPrice();
        System.out.println(priceInt);
        
        int discount = 0;
        while (priceInt != 0) {
            discount += priceInt % 10;
            priceInt /= 10;
        }
        product.setDiscount(discount);
        System.out.println(product.getDiscount());
        
        oos.writeObject(product);
        
        ois.close();
        oos.close();
        client.close();
    }
}




Sửa sản phẩm - Object Stream
[Mã câu hỏi (qCode): KA1NvzdH].  Thông tin sản phẩm vì một lý do nào đó đã bị sửa đổi thành không đúng, cụ thể:
a) Tên sản phẩm bị đổi ngược từ đầu tiên và từ cuối cùng, ví dụ: “lenovo thinkpad T520” bị chuyển thành “T520 thinkpad lenovo”
b) Số lượng sản phẩm cũng bị đảo ngược giá trị, ví dụ từ 9981 thành 1899
 
Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2209 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng đối tượng (ObjectInputStream / ObjectOutputStream) để gửi/nhận và sửa các thông tin bị sai của sản phẩm. Chi tiết dưới đây:
a) Đối tượng trao đổi là thể hiện của lớp Laptop được mô tả như sau
          •          Tên đầy đủ của lớp: TCP.Laptop
          •          Các thuộc tính: id int, code String, name String, quantity int
          •          Hàm khởi tạo đầy đủ các thuộc tính được liệt kê ở trên
          •          Trường dữ liệu: private static final long serialVersionUID = 20150711;
b)              Tương tác với server theo kịch bản
1)              Gửi đối tượng là chuỗi chứa mã sinh viên và mã câu hỏi với định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;5AD2B818"
2)              Receive một đối tượng là thể hiện của lớp Laptop từ server
3)              Sửa các thông tin sai của sản phẩm về tên và số lượng.  Gửi đối tượng vừa được sửa sai lên server
4)              Đóng socket và kết thúc chương trình.


Code :
package TCP;
 
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
 
/**
 *
 * @author Nauh
 */
public class SuaSanPham {
        public static void main(String[] args) throws IOException, ClassNotFoundException {
            Socket client = new Socket("203.162.10.109", 2209);
        ObjectInputStream ois = new ObjectInputStream(client.getInputStream());
        ObjectOutputStream oos = new ObjectOutputStream(client.getOutputStream());
            
            String msv = "B21DCCN404;KA1NvzdH";
        oos.writeObject(msv);
            oos.flush();
            
            Laptop laptop = (Laptop) ois.readObject();
        System.out.println(laptop);
            
            String name = laptop.getName();
            String[] names = name.split("\\s+");
            String tmp = names[names.length - 1];
            for (int i = 1; i < names.length - 1; i++) {
                tmp += " " + names[i];
            }
            tmp += " " + names[0];
        System.out.println(tmp);
        laptop.setName(tmp);
            
            StringBuilder sb = new StringBuilder(String.valueOf(laptop.getQuantity()));
            String res = sb.reverse().toString();
        laptop.setQuantity(Integer.parseInt(res));
        System.out.println(laptop.getQuantity());
            
        oos.writeObject(laptop);
            
            ois.close();
            oos.close();
        client.close();
        }
}


X - Chuỗi con dài nhất - Byte Stream
[Mã câu hỏi (qCode): nM9Euc9s].  
Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2206 (thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client thực hiện kết nối tới server sử dụng các luồng byte (InputStream/OutputStream) để trao đổi thông tin theo thứ tự:
    a. Gửi mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B16DCCN999;10048F28".
    b. Nhận chuỗi ký tự từ server. Ví dụ: "abcabcbb"
    c. Tìm và gửi lên server chuỗi con dài nhất từ chuỗi nhận được mà không có ký tự lặp lại theo format "longestsubstring;length". Ví dụ: "abc;3".
    d. Đóng kết nối và kết thúc chương trình.


Code:


package TCP;


import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class ChuoiConDaiNhat {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2206);
        InputStream is = client.getInputStream();
        OutputStream os = client.getOutputStream();
        
        String msv = "B21DCCN800;nM9Euc9s";
        os.write(msv.getBytes());
        
        byte[] buffer = new byte[1024];
        is.read(buffer);
        String s = new String(buffer);
        System.out.println(s);
        
        String res = longestSubString(s);
        res = res + ";" + res.length();
        System.out.println(res);
        os.write(res.getBytes());
        
        is.close();
        os.close();
        client.close();
    }


    private static String longestSubString(String s) {
        boolean[] visited = new boolean[256];
        int start = 0;
        String longestSubString = "";
        
        for (int end = 0; end < s.length(); end++) {
            char currentChar = s.charAt(end);
            while (visited[currentChar]) {
                visited[s.charAt(start)] = false;
                start++;
            }
            
            visited[currentChar] = true;
            if (end - start + 1 > longestSubString.length()) {
                longestSubString = s.substring(start, end + 1);
            }
        }
        
        return longestSubString;
    }
}
Giải mã Caesar - Data Stream
[Mã câu hỏi (qCode): 5WsCpEmj].  Mật mã caesar, còn gọi là mật mã dịch chuyển, để giải mã thì mỗi ký tự nhận được sẽ được thay thế bằng một ký tự cách nó một đoạn s. Ví dụ: với s = 3 thì ký tự “A” sẽ được thay thế bằng ký tự “D”.
Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2207 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng chương trình client tương tác với server trên, sử dụng các luồng byte (DataInputStream/DataOutputStream) để trao đổi thông tin theo thứ tự:
a.        Gửi một chuỗi gồm mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;D68C93F7"
b.        Nhận lần lượt chuỗi đã bị mã hóa caesar và giá trị dịch chuyển s nguyên
c.        Thực hiện giải mã ra thông điệp ban đầu và gửi lên Server
d.        Đóng kết nối và kết thúc chương trình.


Code:




package TCP;


import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class GiaiMaCaesar {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2207);
        DataInputStream dis = new DataInputStream(client.getInputStream());
        DataOutputStream dos = new DataOutputStream(client.getOutputStream());
        
        String msv = "B21DCCN680;5WsCpEmj";
        dos.writeUTF(msv);
        
        String encodedString = dis.readUTF();
        System.out.println(encodedString);
        
        int s = dis.readInt();
        System.out.println(s);
        
        StringBuilder decodedString = new StringBuilder();
        for (char i : encodedString.toCharArray()) {
            char tmp = 0;
            if (Character.isUpperCase(i)) {
                tmp = (char) ((i + s - 'A' + 26) % 26 + 'A'); 
            }
            if (Character.isLowerCase(i)) {
                tmp = (char) ((i + s - 'a' + 26) % 26 + 'a');
            }
            decodedString.append(tmp);
            System.out.print(tmp);
        }
        dos.writeUTF(decodedString.toString());
        
        dis.close();
        dos.close();
        client.close();
    }
}


Loại bỏ các ký tự trong chuỗi thứ nhất mà xuất hiện trong chuỗi thứ hai - Character Stream
[Mã câu hỏi (qCode): RWJvxHaS].  [Loại bỏ các ký tự trong chuỗi thứ nhất mà xuất hiện trong chuỗi thứ hai]
Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2208 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng ký tự (BufferedReader/BufferedWriter) theo kịch bản sau:
a.        Gửi một chuỗi gồm mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;DE0C2BF0"
b.        Nhận lần lượt hai chuỗi ngẫu nhiên từ server
c.        Loại bỏ các ký tự trong chuỗi thứ nhất mà xuất hiện trong chuỗi thứ hai, yêu cầu giữ nguyên thứ tự xuất hiện của ký tự. Gửi chuỗi đã được xử lý lên server.
d.        Đóng kết nối và kết thúc chương trình


Code:


package TCP;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class LoaiBoKyTu {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2208);
        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
        
        String msv = "B21DCCN680;RWJvxHaS\n";
        bw.write(msv);
        bw.flush();
        
        String s1 = br.readLine();
        System.out.println(s1);
        String s2 = br.readLine();
        System.out.println(s2);
        
        String res = "";
        for (char i : s1.toCharArray()) {
            if (!s2.contains(String.valueOf(i))) res += i;
        }
        System.out.println(res);
        bw.write(res);
        bw.flush();
        
        br.close();
        bw.close();
        client.close();
    }
}


Định dạng khách hàng - Object Stream
[Mã câu hỏi (qCode): 5r08vtUr].  Thông tin khách hàng cần thay đổi định dạng lại cho phù hợp với khu vực, cụ thể:
a.        Tên khách hàng cần được chuẩn hóa theo định dạng mới. Ví dụ: nguyen van hai duong -> DUONG, Nguyen Van Hai
b.        Ngày sinh của khách hàng hiện đang ở dạng mm-dd-yyyy, cần được chuyển thành định dạng dd/mm/yyyy. Ví dụ: 10-11-2012 -> 11/10/2012
c.        Tài khoản khách hàng là các chữ cái in thường được sinh tự động từ họ tên khách hàng. Ví dụ: nguyen van hai duong -> nvhduong


Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2209 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng đối tượng (ObjectInputStream / ObjectOutputStream) thực hiện gửi/nhận đối tượng khách hàng và chuẩn hóa. Cụ thể:
a.        Đối tượng trao đổi là thể hiện của lớp Customer được mô tả như sau
      •        Tên đầy đủ của lớp: TCP.Customer
      •        Các thuộc tính: id int, code String, name String, dayOfBirth String, userName String
      •        Hàm khởi tạo đầy đủ các thuộc tính được liệt kê ở trên
      •        Trường dữ liệu: private static final long serialVersionUID = 20170711; 
b.        Tương tác với server theo kịch bản dưới đây:
        1) Gửi đối tượng là một chuỗi gồm mã sinh viên và mã câu hỏi ở định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;F2DA54F3"
        2) Nhận một đối tượng là thể hiện của lớp Customer từ server với các thông tin đã được thiết lập
        3) Thay đổi định dạng theo các yêu cầu ở trên và gán vào các thuộc tính tương ứng.  Gửi đối tượng đã được sửa đổi lên server
        4) Đóng socket và kết thúc chương trình.


Code:


package TCP;


import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class DinhDangKhachHang {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Socket client = new Socket("203.162.10.109", 2209);
        ObjectInputStream ois = new ObjectInputStream(client.getInputStream());
        ObjectOutputStream oos = new ObjectOutputStream(client.getOutputStream());
        
        String msv = "B21DCCN680;5r08vtUr";
        oos.writeObject(msv);
        
        Customer cus = (Customer) ois.readObject();
        System.out.println(cus);
        
        String name = cus.getName();
        String dob = cus.getDayOfBirth();
        
        String[] strings = name.toLowerCase().split("\\s+");
        String newName = strings[strings.length - 1].toUpperCase() + ",";
        String userName = strings[strings.length - 1];
        
        String tmp = "";
        for (int i = 0; i < strings.length - 1; i++) {
            newName += " " + String.valueOf(strings[i].charAt(0)).toUpperCase() + strings[i].substring(1);
            tmp += strings[i].charAt(0);
        }
        userName = tmp + userName;
        
        System.out.println(newName);
        System.out.println(userName);
        cus.setName(newName);
        cus.setUserName(userName);
        
        String[] dobs = dob.split("-");
        dob = dobs[1] + "/" + dobs[0] + "/" + dobs[2];
        System.out.println(dob);
        cus.setDayOfBirth(dob);
        
        oos.writeObject(cus);
        
        ois.close();
        oos.close();
        client.close();
    }
}


Sắp xếp các từ theo thứ tự từ điển - Character Stream
[Mã câu hỏi (qCode): 63JV3N5x].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2208 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5 giây). Yêu cầu là xây dựng một chương trình client thực hiện kết nối tới server và sử dụng luồng ký tự (BufferedWriter/BufferedReader) để trao đổi thông tin theo kịch bản sau:
a. Gửi một chuỗi gồm mã sinh viên và mã câu hỏi với định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;X1107ABC".
b. Nhận từ server một chuỗi ngẫu nhiên chứa nhiều từ, các từ phân tách bởi khoảng trắng.
c. Thực hiện các bước xử lý:
    Bước 1: Tách chuỗi thành các từ dựa trên khoảng trắng.
    Bước 2: Sắp xếp các từ theo thứ tự từ điển (có phân biệt chữ cái hoa thường).
d. Gửi lại chuỗi đã sắp xếp theo thứ tự từ điển lên server.


e. Đóng kết nối và kết thúc chương trình.


Code:


package TCP;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


/**
 *
 * @author Nauh
 */
public class SapXepCacTu {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2208);
        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
        
        String msv = "B21DCCN800;63JV3N5x\n";
        bw.write(msv);
        bw.flush();
        
        String s = br.readLine();
        System.out.println(s);
        
        String[] words = s.trim().split("\\s+");
        List<String> list = new ArrayList<>();
        for (String word : words) {
            list.add(word);
        }
        Collections.sort(list);
        String res = "";
        for (String i : list) {
            res += i + " ";
        }
        bw.write(res);
        bw.flush();
        
        br.close();
        bw.close();
        client.close();
    }
}


Chuyển đổi điểm số gpa sang dạng điểm chữ - Object Stream
[Mã câu hỏi (qCode): gCSo6fHA].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2209 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng đối tượng(ObjectOutputStream/ObjectInputStream) theo kịch bản dưới đây:
Biết lớp TCP.Student gồm các thuộc tính (id int,code String, gpa float, gpaLetter String) và 
private static final long serialVersionUID = 20151107;
a.        Gửi đối tượng là một chuỗi gồm mã sinh viên và mã câu hỏi với định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;1D059A3F"
b.        Nhận một đối tượng là thể hiện của lớp TCP.Student từ server
c.        Chuyển đổi giá trị điểm số gpa của đối tượng nhận được sang dạng điểm chữ và gán cho gpaLetter.  Nguyên tắc chuyển đổi
i.        3.7 – 4 -> A
ii.        3.0 – 3.7 -> B
iii.        2.0 – 3.0 -> C
iv.        1.0 – 2.0 -> D
v.        0 – 1.0 -> F
d.     Gửi đối tượng đã được xử lý ở trên lên server.
e.     Đóng kết nối và kết thúc chương trình


Code:


package TCP;


import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class ChuyenDoiDiem {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Socket client = new Socket("203.162.10.109", 2209);
        ObjectInputStream ois = new ObjectInputStream(client.getInputStream());
        ObjectOutputStream oos = new ObjectOutputStream(client.getOutputStream());
        
        String msv = "B21DCCN800;gCSo6fHA";
        oos.writeObject(msv);
        
        Student student = (Student) ois.readObject();
        System.out.println(student);
        
        if (student.getGpa() <= 1) student.setGpaLetter("F");
        else if (student.getGpa() <= 2) student.setGpaLetter("D");
        else if (student.getGpa() <= 3) student.setGpaLetter("C");
        else if (student.getGpa() <= 3.7) student.setGpaLetter("B");
        else student.setGpaLetter("A");
        
        oos.writeObject(student);
        
        ois.close();
        oos.close();
        client.close();
    }
}


X - Chuỗi con tăng dài nhất - Byte Stream
[Mã câu hỏi (qCode): 3UUMjDHC].  Một chương trình server hỗ trợ kết nối qua giao thức TCP tại cổng 2206 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu xây dựng chương trình client thực hiện kết nối tới server sử dụng luồng byte dữ liệu (InputStream/OutputStream) để trao đổi thông tin theo thứ tự:
    a. Gửi mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B16DCCN999;76B68B3B".
    b. Nhận dữ liệu từ server là một chuỗi các giá trị số nguyên được phân tách bởi ký tự ",". Ví dụ: 5,10,20,25,50,40,30,35.
    c. Tìm chuỗi con tăng dần dài nhất và gửi độ dài của chuỗi đó lên server theo format "chuỗi tăng dài nhất; độ dài". Ví dụ: 5,10,20,25,50;5
    d. Đóng kết nối và kết thúc chương trình.


Code:




package TCP;


import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


/**
 *
 * @author Nauh
 */
public class ChuoiConTangDaiNhat {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2206);
        InputStream is = client.getInputStream();
        OutputStream os = client.getOutputStream();
        
        String msv = "B21DCCN344;3UUMjDHC";
        os.write(msv.getBytes());
        
        byte[] buffer = new byte[1024];
        is.read(buffer);
        String s = new String(buffer);
        System.out.println(s);
        
        String[] numbers = s.trim().split(",");
        int[] nums = Arrays.stream(numbers).mapToInt(Integer::parseInt).toArray();
        List<Integer> longestSubsequence = findLongestSub(nums);
        
        StringBuilder res = new StringBuilder();
        for (int i : longestSubsequence) {
            res.append(i).append(",");
        }
        res.deleteCharAt(res.length() - 1);
        res.append(";").append(longestSubsequence.size());
        System.out.println(res);
        
        os.write(res.toString().getBytes());
         
        is.close();
        os.close();
        client.close();
    }


    private static List<Integer> findLongestSub(int[] nums) {
        int[] dp = new int[nums.length];
        int[] prev = new int[nums.length];
        
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;
            prev[i] = -1;
        }
        
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j] && dp[i] < dp[j] + 1) {
                    dp[i] = dp[j] + 1;
                    prev[i] = j;
                }
            }
        }
        
        int maxLength = 0;
        int maxIndex = -1;
        for (int i = 0; i < dp.length; i++) {
            if (dp[i] > maxLength) {
                maxLength = dp[i];
                maxIndex = i;
            }
        }
        
        List<Integer> res = new ArrayList<>();
        while (maxIndex != -1) {
            res.add(0, nums[maxIndex]);
            maxIndex = prev[maxIndex];
        }
        return res;
    }
}


Giá trị lớn thứ 2 cùng vị trí xuất hiện - Byte Stream
[Mã câu hỏi (qCode): V0PcdlBF].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2206 (thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác tới server ở trên sử dụng các luồng byte (InputStream/OutputStream) để trao đổi thông tin theo thứ tự: 
a.        Gửi mã sinh viên và mã câu hỏi theo định dạng "studentCode;qCode". Ví dụ: "B16DCCN999;2B3A6510"
b.        Nhận dữ liệu từ server là một chuỗi các giá trị số nguyên được phân tách nhau bởi ký tự ",". Ví dụ: 1,3,9,19,33,20
c.        Tìm và gửi lên server giá trị lớn thứ hai cùng vị trí xuất hiện của nó trong chuỗi.Ví dụ: 20,5
d.        Đóng kết nối và kết thúc chương trình.


Code:


package TCP;


import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;


/**
 *
 * @author Nauh
 */
public class GiaTriLonThu2 {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2206);
        InputStream is = client.getInputStream();
        OutputStream os = client.getOutputStream();
        
        String msv = "B21DCCN380;V0PcdlBF";
        os.write(msv.getBytes());
        
        byte[] buffer = new byte[1024];
        is.read(buffer);
        String s = new String(buffer);
        System.out.println(s);
        List<Integer> list = new ArrayList<>();
        String[] numbers = s.trim().split(",");
        for (String number : numbers) {
            list.add(Integer.parseInt(number));
        }        
        
        Set<Integer> set = new TreeSet<>(Collections.reverseOrder());
        set.addAll(list);
        Iterator<Integer> iterator = set.iterator();
        iterator.next();
        int secondNumber = iterator.next();
        int position = list.indexOf(secondNumber);
       
        String res = secondNumber + "," + position;
        os.write(res.getBytes());
        
        is.close();
        os.close();
        client.close();
    }
}




Tìm từ dài nhất - Character Stream
[Mã câu hỏi (qCode): 9a5nOL3t].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2208 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5 giây). Yêu cầu là xây dựng một chương trình client thực hiện kết nối tới server và sử dụng luồng ký tự (BufferedWriter/BufferedReader) để trao đổi thông tin theo kịch bản sau:
a. Gửi một chuỗi gồm mã sinh viên và mã câu hỏi với định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;A1B2C3D4".
b. Nhận từ server một chuỗi ngẫu nhiên.
c. Xử lý chuỗi đã nhận theo các bước sau:
    Bước 1: Tìm từ dài nhất trong trong chuỗi ngẫu nhiên (từ là chuỗi con phân tách bởi khoảng trắng). 
    Bước 2: Xác định vị trí bắt đầu của từ dài nhất đó trong chuỗi ban đầu.
d. Gửi lần lượt hai giá trị lên server:
   - Từ dài nhất xuất hiện trong chuỗi.
   - Vị trí bắt đầu của từ trong chuỗi ban đầu.


e. Đóng kết nối và kết thúc chương trình.


Code:


package TCP;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;


/**
 *
 * @author Nauh
 */
public class TuDaiNhat {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2208);
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
        
        String msv = "B21DCCN380;9a5nOL3t";
        bw.write(msv);
        bw.newLine();
        bw.flush();
        
        String s = br.readLine();
        System.out.println(s);
        
        String[] words = s.trim().split("\\s+");
        String longestWord = "";
        int longestWordIndex = -1;
        for (String word : words) {
            if (word.length() > longestWord.length()) {
                longestWord = word;
            }
        }
        
        longestWordIndex = s.indexOf(longestWord);
        
        System.out.println(longestWord);
        System.out.println(longestWordIndex);
        bw.write(longestWord);
        bw.newLine();
        bw.flush();
        bw.write(String.valueOf(longestWordIndex));
        bw.flush();
        
        br.close();
        bw.close();
        client.close();
    }
}


Ký tự xuất hiện nhiều hơn 1 lần và số lần xuất hiện trong chuỗi - Character Stream
[Mã câu hỏi (qCode): 7Y5iwP1R].  Một chương trình server cho phép kết nối qua giao thức TCP tại cổng 2208 (hỗ trợ thời gian giao tiếp tối đa cho mỗi yêu cầu là 5s). Yêu cầu là xây dựng một chương trình client tương tác với server sử dụng các luồng byte (BufferedWriter/BufferedReader) theo kịch bản sau: 
a.        Gửi một chuỗi gồm mã sinh viên và mã câu hỏi với định dạng "studentCode;qCode". Ví dụ: "B15DCCN999;BAA62945"
b.        Nhận một chuỗi ngẫu nhiên từ server
Ví dụ: dgUOo ch2k22ldsOo
c.        Liệt kê các ký tự (là chữ hoặc số) xuất hiện nhiều hơn một lần trong chuỗi và số lần xuất hiện của chúng và gửi lên server
Ví dụ: d:2,O:2,o:2,2:3,
d.        Đóng kết nối và kết thúc chương trình.


Code:


package TCP;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.util.LinkedHashMap;
import java.util.Map;


/**
 *
 * @author Nauh
 */
public class KyTuXuatHienNhieuHon1Lan {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("203.162.10.109", 2208);
        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
        
        String msv = "B21DCCN263;7Y5iwP1R\n";
        bw.write(msv);
        bw.flush();
        
        String s = br.readLine();
        System.out.println(s);
        Map<Character, Integer> map = new LinkedHashMap<>();
        for (char c : s.toCharArray()) {
           if(Character.isLetterOrDigit(c)) map.put(c, map.getOrDefault(c, 0) + 1);
        }
        
        String res = "";
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            if(entry.getValue() > 1) res += entry.getKey() + ":" + entry.getValue() + ",";
        }
        System.out.println(res);
        
        bw.write(res);
        bw.flush();
        
        br.close();
        bw.close();
        client.close();
    }
}




UDP
Chuẩn hóa chuỗi - String
[Mã câu hỏi (qCode): WvfAdDOD].  Một chương trình server cho phép kết nối qua giao thức UDP tại cổng 2208. Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản dưới đây:
a.              Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng “;studentCode;qCode”. Ví dụ: “;B15DCCN001;5B35BCC1”
b.              Nhận thông điệp từ server theo định dạng “requestId;data”
-                requestId là một chuỗi ngẫu nhiên duy nhất
-                data là chuỗi dữ liệu cần xử lý
c.              Xử lý chuẩn hóa chuỗi đã nhận thành theo nguyên tắc
i.               Ký tự đầu tiên của từng từ trong chuỗi là in hoa
ii.              Các ký tự còn lại của chuỗi là in thường
Gửi thông điệp chứa chuỗi đã được chuẩn hóa lên server theo định dạng “requestId;data”
d.              Đóng socket và kết thúc chương trình
 
Code:
 
package udp.chuan_hoa_chuoi;
 
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
 
/**
 *
 * @author Nauh
 */
public class UDPClient {
        public static String normalizeString(String data){
            String[] words = data.toLowerCase().split("\\s+");
            StringBuilder sb = new StringBuilder();
            for(String word: words){
            sb.append(Character.toUpperCase(word.charAt(0)))
                    .append(word.substring(1))
                    .append(" ");
                
            }
            return sb.toString().trim();
        }
        public static void main(String[] args) throws SocketException, UnknownHostException, IOException {
            DatagramSocket client = new DatagramSocket();
            String msv = ";B21DCCN404;WvfAdDOD";
            byte[] sendData = msv.getBytes();
            DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, InetAddress.getByName("203.162.10.109"), 2208);
        client.send(dpReq);
            
            byte[] buffer = new byte[1024];
            DatagramPacket dpRes = new DatagramPacket(buffer, buffer.length);
        client.receive(dpRes);
            String strRes = new String(dpRes.getData()).trim();
        System.out.println(strRes);
            
            String[] parts = strRes.split(";");
            String requestId = parts[0];
            String data = parts[1];
            String normalizedData = normalizeString(data);
            String responseMessage = requestId + ";" + normalizedData;
            sendData = responseMessage.getBytes();
            dpReq = new DatagramPacket(sendData, sendData.length, InetAddress.getByName("203.162.10.109"), 2208);
        client.send(dpReq);
        System.out.println(responseMessage);
            
        client.close();
        }
}
 
Tìm max, min- Data type
[Mã câu hỏi (qCode): ayt2sCVY].  Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2207. Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản:
a.              Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng “;studentCode;qCode”. Ví dụ: “;B15DCCN001;DC73CA2E”
b.              Nhận thông điệp là một chuỗi từ server theo định dạng “requestId;a1,a2,...,a50”
-                requestId là chuỗi ngẫu nhiên duy nhất
-                a1 -> a50 là 50 số nguyên ngẫu nhiên
c.              Thực hiện tìm giá trị lớn nhất và giá trị nhỏ nhất thông điệp trong a1 -> a50 và gửi thông điệp lên lên server theo định dạng “requestId;max,min”
d.              Đóng socket và kết thúc chương trình
Code:
 
package udp.tim_max_min;
 
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
 
/**
 *
 * @author Nauh
 */
public class UDPClient {
        public static void main(String[] args) throws SocketException, UnknownHostException, IOException {
            DatagramSocket client = new DatagramSocket();
            InetAddress address = InetAddress.getByName("203.162.10.109");
            int port = 2207;
                    
            String msv = ";B21DCCN404;ayt2sCVY";
            byte[] sendData = msv.getBytes();
            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(sendPacket);
            
            byte[] receiveData = new byte[1024];
            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
        client.receive(receivePacket);
            String s = new String(receivePacket.getData()).trim();
        System.out.println(s);
            String[] parts = s.split(";");
            String requestId = parts[0];
            String[] numbers = parts[1].split(",");
            int max = Integer.MIN_VALUE;
            int min =  Integer.MAX_VALUE;
            for(String iString: numbers){
                int x = Integer.parseInt(iString);
            if(x>max) max = x;
            if(x<min) min = x;
            }
            String res = requestId + ";" + max + "," + min;
        System.out.println(res);
            sendData = res.getBytes();
            sendPacket = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(sendPacket);
            
        client.close();
            
        }
}
 
Số lớn thứ hai và số nhỏ thứ hai - Data Type
[Mã câu hỏi (qCode): toFVhCmr]. 
Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2207. Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản:
a. Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng “;studentCode;qCode”. Ví dụ: “;B15DCCN004;99D9F604”
b. Nhận thông điệp là một chuỗi từ server theo định dạng “requestId;z1,z2,...,z50” requestId là chuỗi ngẫu nhiên duy nhất
        z1 -> z50 là 50 số nguyên ngẫu nhiên
        c. Thực hiện tính số lớn thứ hai và số nhỏ thứ hai của thông điệp trong z1 -> z50 và gửi thông điệp lên server theo định dạng “requestId;secondMax,secondMin”
        d. Đóng socket và kết thúc chương trình
Code:
 
package udp.so_lon_thu_hai_va_so_nho_thu_hai;
 
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
 
/**
 *
 * @author Nauh
 */
public class UDPClient {
        public static void main(String[] args) throws SocketException, UnknownHostException, IOException {
            DatagramSocket client = new DatagramSocket();
            InetAddress address = InetAddress.getByName("203.162.10.109");
            int port = 2207;
            
            String msv = ";B21DCCN404;toFVhCmr";
            byte[] sendData = msv.getBytes();
            DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
            
            byte[] receiveData = new byte[1024];
            DatagramPacket dpRes = new DatagramPacket(receiveData, receiveData.length);
        client.receive(dpRes);
            
            String s = new String(dpRes.getData()).trim();
        System.out.println(s);
            String[] parts = s.split(";");
            String requestId = parts[0];
            String[] numbers = parts[1].split(",");
            int max = Integer.MIN_VALUE;
            int min = Integer.MAX_VALUE;
            for(String iString: numbers){
                int x = Integer.parseInt(iString);
                if(x > max) max = x;
                if(x < min) min = x;
            }
            int max2 = Integer.MIN_VALUE;
            int min2 = Integer.MAX_VALUE;
            for(String iString: numbers){
                int x = Integer.parseInt(iString);
                if(x != max && x > max2) max2 = x;
                if(x != min && x < min2) min2 = x;
            }
            String res = requestId + ";" + max2 + "," + min2;
        System.out.println(res);
            sendData = res.getBytes();
            dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
            
        client.close();
        }
}
 
Sửa sản phẩm - Object
[Mã câu hỏi (qCode): 1kqJGCHJ].  Thông tin sản phẩm vì một lý do nào đó đã bị sửa đổi thành không đúng, cụ thể:
a.              Tên sản phẩm bị đổi ngược từ đầu tiên và từ cuối cùng, ví dụ: “lenovo thinkpad T520” bị chuyển thành “T520 thinkpad lenovo”
b.              Số lượng sản phẩm cũng bị đảo ngược giá trị, ví dụ từ 9981 thành 1899
 
Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2209. Yêu cầu là xây dựng một chương trình client giao tiếp với server để gửi/nhận các sản phẩm theo mô tả dưới đây:
a.              Đối tượng trao đổi là thể hiện của lớp Product được mô tả như sau
•                Tên đầy đủ của lớp: UDP.Product
•                Các thuộc tính: id String, code String, name String, quantity int
•                Một hàm khởi tạo có đầy đủ các thuộc tính được liệt kê ở trên
•                Trường dữ liệu: private static final long serialVersionUID = 20161107;
b.              Giao tiếp với server theo kịch bản
•           Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng “;studentCode;qCode”. Ví dụ: “;B15DCCN001;EE29C059”
 
•                Nhận thông điệp chứa: 08 byte đầu chứa chuỗi requestId, các byte còn lại chứa một đối tượng là thể hiện của lớp Product từ server. Trong đối tượng này, các thuộc tính id, name và quantity đã được thiết lập giá trị.
•                Sửa các thông tin sai của đối tượng về tên và số lượng như mô tả ở trên và gửi đối tượng vừa được sửa đổi lên server theo cấu trúc:
08 byte đầu chứa chuỗi requestId và các byte còn lại chứa đối tượng Product đã được sửa đổi.
•                Đóng socket và kết thúc chương trình.
Code
 
package UDP.sua_san_pham;
 
import UDP.Product;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
 
/**
 *
 * @author Nauh
 */
public class UDPClient {
        public static void main(String[] args) throws SocketException, UnknownHostException, IOException, ClassNotFoundException {
            DatagramSocket client = new DatagramSocket();
            InetAddress address = InetAddress.getByName("203.162.10.109");
            int port = 2209;
            
            String msv = ";B21DCCN404;1kqJGCHJ";
            byte[] sendData = msv.getBytes();
            DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
            
            byte[] receiveData = new byte[1024];
            DatagramPacket dpRes = new DatagramPacket(receiveData, receiveData.length);
        client.receive(dpRes);
            
        ByteArrayInputStream bais = new ByteArrayInputStream(dpRes.getData(), 8, dpRes.getLength()- 8);
            String requestId = new String(dpRes.getData()).trim().substring(0, 8);
        System.out.println(requestId);
            
        ObjectInputStream ois = new ObjectInputStream(bais);
            Product product = (Product) ois.readObject();
        System.out.println(product);
            
            String name = product.getName();
        System.out.println(name);
            String[] strings = name.split("\\s+");
            String res = strings[strings.length - 1];
            for(int i=1; i< strings.length - 1;i++){
                res += " " + strings[i];
            }
            res += " " + strings[0];
        System.out.println(res);
        product.setName(res);
            
            
            StringBuilder sb = new StringBuilder(String.valueOf(product.getQuantity()));
            String tmp = sb.reverse().toString();
        product.setQuantity(Integer.parseInt(tmp));
        System.out.println(product.getQuantity());
            
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(requestId.getBytes());
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(product);
            receiveData = baos.toByteArray();
            dpReq = new DatagramPacket(receiveData, receiveData.length, address, port);
        client.send(dpReq);
            
        client.close();
        }
}
 
Giải mã Caesar - Data Type
[Mã câu hỏi (qCode): TvZr39m9].  Mật mã caesar, còn gọi là mật mã dịch chuyển, để giải mã thì mỗi ký tự nhận được sẽ được thay thế bằng một ký tự cách nó một đoạn s. Ví dụ: với s = 3 thì ký tự “A” sẽ được thay thế bằng ký tự “D”.
Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2207. Yêu cầu xây dựng chương trình client trao đổi thông tin với server theo kịch bản mô tả dưới đây:
a.        Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng ";studentCode;qCode". Ví dụ: ";B15DCCN001;825EE3A7"
b.        Nhận thông điệp là một chuỗi từ server theo định dạng "requestId;strEncode;s".
•        requestId là chuỗi ngẫu nhiên duy nhất
•        strEncode là chuỗi thông điệp bị mã hóa
•        s là số nguyên chứa giá trị độ dịch của mã
c.        Giải mã tìm thông điệp ban đầu và gửi lên server theo định dạng “requestId;strDecode”
d.        Đóng socket và kết thúc chương trình.
Code:


package UDP;


import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;


/**
 *
 * @author Nauh
 */
public class GiaiMaCaesar {
    public static void main(String[] args) throws UnknownHostException, SocketException, IOException {
        DatagramSocket client = new DatagramSocket();
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2207;
        
        String msv = ";B21DCCN380;TvZr39m9";
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String string = new String(dpRes.getData());
        System.out.println(string);
        
        String[] parts = string.trim().split(";");
        String requestId = parts[0];
        String strEncode = parts[1];
        int s = Integer.parseInt(parts[2]);
        
        String strDecode = "";
        for (char c : strEncode.toCharArray()) {
            if (Character.isUpperCase(c)) {
                strDecode += (char) ((c + s - 'A' + 26) % 26 + 'A');
            }
            if (Character.isLowerCase(c)) {
                strDecode += (char) ((c + s - 'a' + 26) % 26 + 'a');
            }
        }
        System.out.println(strDecode);
        
        String res = requestId + ";" + strDecode;
        sendData = res.getBytes();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        client.close();
    }
}


Tìm các giá trị còn thiếu - Data Type
[Mã câu hỏi (qCode): sA9T0LMp].  Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2207. Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản:
a.              Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng “;studentCode;qCode”. Ví dụ: “;B15DCCN001;371EA16D”
b.              Nhận thông điệp là một chuỗi từ server theo định dạng “requestId; n; A1,A2,...An”, với
-                requestId là chuỗi ngẫu nhiên duy nhất
-                n là một số ngẫu nhiên nhỏ hơn 100.
-                A1, A2 ... Am với m <= n là các giá trị nguyên liên tiếp, nhỏ hơn hoặc bằng n và không trùng nhau.
Ví dụ: requestId;10;2,3,5,6,9
c.              Tìm kiếm các giá trị còn thiếu và gửi lên server theo định dạng “requestId;B1,B2,...,Bm”
Ví dụ: requestId;1,4,7,8,10
d.              Đóng socket và kết thúc chương trình.
Code
 
 
package UDP;
 
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.HashSet;
import java.util.Set;
 
/**
 *
 * @author Nauh
 */
public class TimCacGiaTriConThieu {
        public static void main(String[] args) throws SocketException, UnknownHostException, IOException {
            DatagramSocket client = new DatagramSocket();
            InetAddress address = InetAddress.getByName("203.162.10.109");
            int port = 2207;
            
            String msv = ";B21DCCN404;sA9T0LMp";
            byte[] sendData = msv.getBytes();
            DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
            
            
            byte[] receiveData = new byte[1024];
            DatagramPacket dpRes = new DatagramPacket(receiveData, receiveData.length);
        client.receive(dpRes);
            
            String s = new String(receiveData, 0, receiveData.length).trim();
            
        System.out.println(s);
            String[] parts = s.split(";");
            String requestId = parts[0];
            int n= Integer.parseInt(parts[1]);
            String[] numbers = parts[2].split(",");
            
        Set<Integer> set = new HashSet<>();
            for(String iString: numbers) {
            set.add(Integer.parseInt(iString));
            }
            
            String res = requestId + ";";
//        System.out.println(res);
 
            for(int i=1; i<= n; i++) {
            if(!set.contains(i)) {
                    res += i + ",";
                }
            }
            res = res.substring(0, res.length() - 1);
        System.out.println(res);
            sendData = res.getBytes();
            
            dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        client.close();
        }
}
Loại bỏ các ký tự trong chuỗi thứ nhất mà xuất hiện trong chuỗi thứ hai - String
[Mã câu hỏi (qCode): 7Eu425Vn].  [Loại bỏ ký tự đặc biệt và ký tự trùng giữ nguyên thứ tự xuất hiện]
Một chương trình server cho phép kết nối qua giao thức UDP tại cổng 2208 . Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản dưới đây:
a.        Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng ";studentCode;qCode”. Ví dụ: ";B15DCCN001;B34D51E0"
b.        Nhận thông điệp là một chuỗi từ server theo định dạng "requestId;str1;str2".
•        requestId là chuỗi ngẫu nhiên duy nhất
•        str1,str2 lần lượt là chuỗi thứ nhất và chuỗi thứ hai
c.        Loại bỏ các ký tự trong chuỗi thứ nhất mà xuất hiện trong chuỗi thứ hai, giữ nguyên thứ tự xuất hiện. Gửi thông điệp là một chuỗi lên server theo định dạng "requestId;strOutput", trong đó chuỗi strOutput là chuỗi đã được xử lý ở trên.
d.        Đóng socket và kết thúc chương trình.


Code:


package UDP;


import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;


/**
 *
 * @author Nauh
 */
public class LoaiBoKyTu {
    public static void main(String[] args) throws SocketException, UnknownHostException, IOException {
        DatagramSocket client = new DatagramSocket();
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2208;
        String msv = ";B21DCCN290;7Eu425Vn";
        
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String s = new String(dpRes.getData()).trim();
        System.out.println(s);
        
        String[] strings = s.split(";");
        String requestId = strings[0];
        String str1 = strings[1];
        String str2 = strings[2];
        
        String res = requestId + ";";
        for (int i = 0; i < str1.length(); i++) {
            if (!str2.contains(String.valueOf(str1.charAt(i)))) {
                res += str1.charAt(i);
            }
        }
        System.out.println(res);
        
        sendData = res.getBytes();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        client.close();
    }
}


Định dạng khách hàng - Object
[Mã câu hỏi (qCode): fIltiMsq].  Thông tin khách hàng được yêu cầu thay đổi định dạng lại cho phù hợp với khu vực, cụ thể:
a.        Tên khách hàng cần được chuẩn hóa theo định dạng mới. Ví dụ: nguyen van hai duong -> DUONG, Nguyen Van Hai
b.        Ngày sinh của khách hàng đang ở dạng mm-dd-yyyy, cần được chuyển thành định dạng dd/mm/yyyy. Ví dụ: 10-11-2012 -> 11/10/2012
c.        Tài khoản khách hàng được tạo từ các chữ cái in thường được sinh tự động từ họ tên khách hàng. Ví dụ: nguyen van hai duong -> nvhduong




Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2209. Yêu cầu là xây dựng một chương trình client giao tiếp với server theo mô tả sau:
a.        Đối tượng trao đổi là thể hiện của lớp UDP.Customer được mô tả như sau
•        Tên đầy đủ của lớp: UDP.Customer
•        Các thuộc tính: id String, code String, name String, , dayOfBirth String, userName String
•        Một Hàm khởi tạo với đầy đủ các thuộc tính được liệt kê ở trên
•        Trường dữ liệu: private static final long serialVersionUID = 20151107; 


b.        Client giao tiếp với server theo các bước
•       Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng “;studentCode;qCode”. Ví dụ: “;B15DCCN001;EE29C059”


•        Nhận thông điệp chứa: 08 byte đầu chứa chuỗi requestId, các byte còn lại chứa một đối tượng là thể hiện của lớp Customer từ server. Trong đó, các thuộc tính id, code, name,dayOfBirth đã được thiết lập sẵn.
•        Yêu cầu thay đổi thông tin các thuộc tính như yêu cầu ở trên và gửi lại đối tượng khách hàng đã được sửa đổi lên server với cấu trúc:
08 byte đầu chứa chuỗi requestId và các byte còn lại chứa đối tượng Customer đã được sửa đổi.
•        Đóng socket và kết thúc chương trình.


Code:




package UDP;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;


/**
 *
 * @author Nauh
 */
public class ThayDoiThongTinKhachHang {
    public static void main(String[] args) throws SocketException, UnknownHostException, IOException, ClassNotFoundException {
        DatagramSocket client = new DatagramSocket();
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2209;
        
        String msv = ";B21DCCN290;fIltiMsq";
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String requestId = new String(dpRes.getData()).trim().substring(0, 8);
        System.out.println(requestId);
        
        ByteArrayInputStream bais = new ByteArrayInputStream(dpRes.getData(), 8, dpRes.getLength() - 8);
        ObjectInputStream ois = new ObjectInputStream(bais);
        Customer customer = (Customer) ois.readObject();
        System.out.println(customer);
        
        String name = customer.getName().toLowerCase();
        String[] names = name.split("\\s+");
        String newName = names[names.length - 1].toUpperCase() + ",";
        String userName = names[names.length - 1].toLowerCase();
        String tmp = "";
        for (int i = 0; i < names.length - 1; i++) {
            newName += " " + String.valueOf(names[i].charAt(0)).toUpperCase() + names[i].substring(1).toLowerCase();
            tmp += names[i].charAt(0);
        }
        userName = tmp + userName;
        
        System.out.println(newName);
        System.out.println(userName);
        customer.setName(newName);
        customer.setUserName(userName);
        
        String dob = customer.getDayOfBirth();
        String[] dobs = dob.split("-");
        dob = dobs[1] + "/" + dobs[0] + "/" + dobs[2];
        customer.setDayOfBirth(dob);
        System.out.println(customer.getDayOfBirth());
        
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(requestId.getBytes());
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(customer);
        
        sendData = baos.toByteArray();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        client.close();
    }
}




Loại bỏ ký tự đặc biệt, số, ký tự trùng và giữ nguyên thứ tự xuất hiện của chúng - String
 [Mã câu hỏi (qCode): 9aZn22pO].  [Loại bỏ ký tự đặc biệt, số, trùng và giữ nguyên thứ tự xuất hiện]
Một chương trình server cho phép kết nối qua giao thức UDP tại cổng 2208 . Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản dưới đây:
a.        Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng ";studentCode;qCode". Ví dụ: ";B15DCCN001;06D6800D"
b.        Nhận thông điệp là một chuỗi từ server theo định dạng "requestId;strInput"
•        requestId là chuỗi ngẫu nhiên duy nhất
•        strInput là chuỗi thông điệp cần xử lý
c.        Thực hiện loại bỏ ký tự đặc biệt, số, ký tự trùng và giữ nguyên thứ tự xuất hiện của chúng. Gửi thông điệp lên server theo định dạng "requestId;strOutput", trong đó strOutput là chuỗi đã được xử lý ở trên
d.        Đóng socket và kết thúc chương trình.
Code:


package UDP;


import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.LinkedHashSet;
import java.util.Set;


/**
 *
 * @author Nauh
 */
public class LoaiBoKyTuDacBiet {
    public static void main(String[] args) throws SocketException, UnknownHostException, IOException, IOException {
        DatagramSocket client = new DatagramSocket();
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2208;
        
        String msv = ";B21DCCN096;9aZn22pO";
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String s = new String(dpRes.getData());
        System.out.println(s);
        String[] parts = s.split(";");
        String requestId = parts[0];
        String strInput = parts[1];
        
        Set<Character> set = new LinkedHashSet<>();
        for (char c : strInput.toCharArray()) {
            if (Character.isLetter(c)) {
                set.add(c);
            }
        }
        
        StringBuilder strOutput = new StringBuilder();
        strOutput.append(requestId).append(";");
        for (char c : set) {
            strOutput.append(c);
        }
        System.out.println(strOutput.toString());
        sendData = strOutput.toString().getBytes();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        client.close();
        
    }
}




Student- Object
[Mã câu hỏi (qCode): KPZD2ATU].  Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2209. Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản sau:
Đối tượng trao đổi là thể hiện của lớp UDP.Student được mô tả:
•        Tên đầy đủ lớp: UDP.Student
•        Các thuộc tính: id String,code String, name String, email String
•        02 Hàm khởi tạo: 
o        public Student(String id, String code, String name, String email)
o        public Student(String code)
•        Trường dữ liệu: private static final long serialVersionUID = 20171107
Thực hiện:
•       Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng “;studentCode;qCode”. Ví dụ: “;B15DCCN001;EE29C059”
b.        Nhận thông điệp chứa: 08 byte đầu chứa chuỗi requestId, các byte còn lại chứa một đối tượng là thể hiện của lớp Student từ server. Trong đó, các thông tin được thiết lập gồm id và name.
c.        Yêu cầu:
-        Chuẩn hóa tên theo quy tắc: Chữ cái đầu tiên in hoa, các chữ cái còn lại in thường và gán lại thuộc tính name của đối tượng
-        Tạo email ptit.edu.vn từ tên người dùng bằng cách lấy tên và các chữ cái bắt đầu của họ và tên đệm. Ví dụ: nguyen van tuan nam -> namnvt@ptit.edu.vn. Gán giá trị này cho thuộc tính email của đối tượng nhận được
-        Gửi thông điệp chứa đối tượng xử lý ở bước c lên Server với cấu trúc: 08 byte đầu chứa chuỗi requestId và các byte còn lại chứa đối tượng Student đã được sửa đổi.
d.        Đóng socket và kết thúc chương trình.


Code:


package UDP;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;


/**
 *
 * @author Nauh
 */
public class ChuanHoaSinhVien {
    public static void main(String[] args) throws SocketException, UnknownHostException, IOException, ClassNotFoundException {
        DatagramSocket client = new DatagramSocket();
        String msv = ";B21DCCN032;KPZD2ATU";
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2209;
        
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String requestId = new String(dpRes.getData()).substring(0, 8);
        System.out.println(requestId);
        
        ByteArrayInputStream bais = new ByteArrayInputStream(dpRes.getData(), 8, dpRes.getLength() - 8);
        ObjectInputStream ois = new ObjectInputStream(bais);
        Student student = (Student) ois.readObject();
        System.out.println(student);
        
        String name = normalizaName(student.getName()); 
        System.out.println(name);
        student.setName(name);
        
        String email = generateEmail(student.getName());
        System.out.println(email);
        student.setEmail(email);
        
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(requestId.getBytes());
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(student);
        
        sendData = baos.toByteArray();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        client.close();
    }


    private static String normalizaName(String name) {
        String[] names = name.toLowerCase().split("\\s+");
        StringBuilder res = new StringBuilder();
        for (String word : names) {
            res.append(Character.toUpperCase(word.charAt(0)))
                    .append(word.substring(1)).append(" ");
        }
        return res.toString().trim();
    }


    private static String generateEmail(String name) {
        String[] names = name.toLowerCase().split("\\s+");
        String lastName = names[names.length - 1];
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < names.length - 1; i++) {
            sb.append(names[i].charAt(0));
        }
        return lastName + sb.toString() + "@ptit.edu.vn";
    }
}






Ký tự xuất hiện nhiều nhất trong chuỗi và vị trí của nó - String 
[Mã câu hỏi (qCode): 0MgyTBn1].  Một chương trình server cho phép kết nối qua giao thức UDP tại cổng 2208. Yêu cầu là xây dựng một chương trình client tương tác với server kịch bản dưới đây:
a.        Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng “;studentCode;qCode”. Ví dụ: “;B15DCCN001;EE29C059”
b.        Nhận thông điệp từ server theo định dạng “requestId; data” 
-        requestId là một chuỗi ngẫu nhiên duy nhất
-        data là chuỗi dữ liệu đầu vào cần xử lý
Ex: “requestId;Qnc8d5x78aldSGWWmaAAjyg3”
c.        Tìm kiếm ký tự xuất hiện nhiều nhất trong chuỗi và gửi lên server theo định dạng “requestId;ký tự xuất hiện nhiều nhất: các vị trí xuất hiện ký tự đó” 
ví dụ: “requestId;8:4,9,”
d.        Đóng socket và kết thúc chương trình


Code:


package UDP;


import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 *
 * @author Nauh
 */
public class KyTuXuatHienNhieuNhat {
    public static void main(String[] args) throws SocketException, UnknownHostException, IOException {
        DatagramSocket client = new DatagramSocket();
        String msv = ";B21DCCN680;0MgyTBn1";
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2208;
        
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String s = new String(dpRes.getData());
        System.out.println(s);
        String[] strings = s.trim().split(";");
        String requestId = strings[0];
        String data = strings[1];
        
        Map<Character, Integer> map = new HashMap<>();
        for (char c : data.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        char mostFrequentChar = ' ';
        int maxFrequency = 0;
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            if (entry.getValue() > maxFrequency) {
                maxFrequency = entry.getValue();
                mostFrequentChar = entry.getKey();
            }
        }
        System.out.println(mostFrequentChar + " " + maxFrequency);
        
        List<Integer> positions = new ArrayList<>();
        for (int i = 0; i < data.length(); i++) {
            if (data.charAt(i) == mostFrequentChar) positions.add(i + 1);
        }
        
        String res = requestId + ";" + mostFrequentChar + ":";
        for (int i : positions) {
            res += i + ",";
        }
        System.out.println(res);
        
        sendData = res.getBytes();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
       
        client.close();
    }
}
Tổng các chữ số - Data Type
[Mã câu hỏi (qCode): F5uvHgBI].  Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2207. Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản:


a. Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng ";studentCode;qCode". Ví dụ: ";B15DCCN011;A1F3D5B7".


b. Nhận thông điệp là một chuỗi từ server theo định dạng "requestId;num", với:
   - requestId là chuỗi ngẫu nhiên duy nhất.
   - num là một số nguyên lớn.


c. Tính tổng các chữ số trong num và gửi lại tổng này về server theo định dạng "requestId;sumDigits".


d. Đóng socket và kết thúc chương trình.


Code:
 
package UDP;


import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;




/**
 *
 * @author Nauh
 */
public class TongChuSo {
    public static void main(String[] args) throws SocketException, UnknownHostException, IOException {
        DatagramSocket client = new DatagramSocket();
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2207;
        
        String msv = ";B21DCCN680;F5uvHgBI";
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String s = new String(dpRes.getData());
        System.out.println(s);
        String[] parts = s.trim().split(";");
        String requestId = parts[0];
        String num = parts[1];
        int sum = 0;
        for (char i : num.toCharArray()) {
            sum += Integer.parseInt(String.valueOf(i));
        }
        System.out.println(sum);
        
        String res = requestId + ";" + sum;
        sendData = res.getBytes();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        client.close();
    }
}
Đếm số lần xuất hiện của từng ký tự - String
[Mã câu hỏi (qCode): sdiz3npe].  Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2208. Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản:


a. Gửi một thông điệp chứa mã sinh viên và mã câu hỏi theo định dạng ";studentCode;qCode". Ví dụ: ";B15DCCN001;9F8C2D3A".
b. Nhận một thông điệp từ server theo định dạng "requestId;data", với:
    requestId là chuỗi ngẫu nhiên duy nhất.
    data là một chuỗi ký tự liên tiếp cần xử lý. Ví dụ: "requestId;aaabbbccdaa"


c. Xử lý chuỗi bằng cách duyệt lần lượt và đếm số lần xuất hiện của từng ký tự. Gửi kết quả về server theo định dạng: "requestId;processedData"
Ví dụ: Với chuỗi "aaazbbbccdaaz", kết quả sẽ là: "requestId;5a2z3b2c1d"


d. Đóng socket và kết thúc chương trình.


Code:


package UDP;


import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.LinkedHashMap;
import java.util.Map;


/**
 *
 * @author Nauh
 */
public class DemSoLanXuatHienKyTu {
    public static void main(String[] args) throws SocketException, UnknownHostException, IOException {
        DatagramSocket client = new DatagramSocket();
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2208;
        
        String msv = ";B21DCCN263;sdiz3npe";
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String data = new String(dpRes.getData(), 0, dpRes.getLength());
        System.out.println(data);
        
        String[] parts = data.split(";");
        String requestId = parts[0];
        String s = parts[1];
        System.out.println(s);
        Map<Character, Integer> map = new LinkedHashMap<>();
        StringBuilder res = new StringBuilder();
        res.append(requestId).append(";");
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            res.append(String.valueOf(entry.getValue())).append(entry.getKey());
        }
        
        System.out.println(res.toString());
        String tmp = res.toString();
        sendData = tmp.getBytes();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        client.close();
    }
}
N số nguyên tố đầu tiên - Data Type
[Mã câu hỏi (qCode): PTYYa0so].  Một chương trình server cho phép giao tiếp qua giao thức UDP tại cổng 2207. Yêu cầu là xây dựng một chương trình client trao đổi thông tin với server theo kịch bản:


a. Gửi thông điệp là một chuỗi chứa mã sinh viên và mã câu hỏi theo định dạng ";studentCode;qCode". Ví dụ: ";B15DCCN009;F3E8B2D4".


b. Nhận thông điệp là một chuỗi từ server theo định dạng "requestId;n, n", với:
--- requestId là chuỗi ngẫu nhiên duy nhất.
--- n là một số nguyên ngẫu nhiên ≤ 100.


c. Tính và gửi về server danh sách n số nguyên tố đầu tiên theo định dạng "requestId;p1,p2,...,pk", trong đó p1,p2,...,pk là các số nguyên tố.


d. Đóng socket và kết thúc chương trình.


Code:


package UDP;


import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.List;


/**
 *
 * @author Nauh
 */
public class NSoNguyenToDauTien {
    public static boolean isPrime(int n) {
        if (n < 2) return false;
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
    public static void main(String[] args) throws UnknownHostException, SocketException, IOException {
        DatagramSocket client = new DatagramSocket();
        InetAddress address = InetAddress.getByName("203.162.10.109");
        int port = 2207;
        String msv = ";B21DCCN410;PTYYa0so";
        
        byte[] sendData = msv.getBytes();
        DatagramPacket dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        byte[] receivedData = new byte[1024];
        DatagramPacket dpRes = new DatagramPacket(receivedData, receivedData.length);
        client.receive(dpRes);
        
        String s = new String(dpRes.getData());
        System.out.println(s);
        
        String[] parts = s.trim().split(";");
        String requestId = parts[0];
        int n = Integer.parseInt(parts[1]);
        String res = requestId + ";";
        List<Integer> primes = new ArrayList<>();
        int number = 2;
        while (primes.size() < n) {
            if (isPrime(number)) {
                primes.add(number);
            }
            number++;
        }
        String primeString = String.join(",", primes.stream().map(String::valueOf).toList());
        res += primeString;
        System.out.println(res);
        
        sendData = res.getBytes();
        dpReq = new DatagramPacket(sendData, sendData.length, address, port);
        client.send(dpReq);
        
        client.close();
        
    }
}






RMI
Chuyển sang chuỗi bát phân - Byte
[Mã câu hỏi (qCode): 6EOWkq5Z].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server.
b. Chuyển đổi mỗi byte trong mảng dữ liệu nhận được thành chuỗi biểu diễn số bát phân (octal). Mỗi byte sẽ được chuyển thành một chuỗi số bát phân gồm ba chữ số (nếu cần, thêm các chữ số 0 ở đầu để đảm bảo đúng định dạng).
Ví dụ: Nếu mảng dữ liệu nhận được là [72, 101, 108], chương trình sẽ thực hiện chuyển đổi từng byte thành dạng bát phân:
•        72 -> "110"
•        101 -> "145"
•        108 -> "154"
Kết quả là chuỗi octal "110145154". Chuyển chuỗi bát phân này trở lại thành mảng byte[] (mỗi ký tự trong chuỗi octal được mã hóa dưới dạng ASCII byte) để gửi về server.
c. Triệu gọi phương thức submitData để gửi mảng byte[] chứa chuỗi bát phân trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;




import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;


public class ChuyenSangChuoiBatPhan {
    public static void main(String[] args) throws Exception {
        String host = "203.162.10.109";
        int port = 1099;
        String serviceName = "RMIByteService";
        
        Registry registry = LocateRegistry.getRegistry(host,port);
        ByteService byteService = (ByteService) registry.lookup(serviceName);
        
        String studentCode = "B21DCCN404";
        String qCode = "6EOWkq5Z";
        
        byte[] receivedData = byteService.requestData(studentCode, qCode);
        for(byte b : receivedData) {
            System.out.print(b + " ");
        }
        System.out.println();
        
        StringBuilder octalString = new StringBuilder();
        for(byte b : receivedData) {
            String octal = String.format("%03o", b);
            octalString.append(octal);
        }
        System.out.println(octalString);


        byte[] octalBytes = octalString.toString().getBytes();
        byteService.submitData(studentCode, qCode, octalBytes);


    }
}


Chuyển sang chuỗi Hex - Byte
[Mã câu hỏi (qCode): kNZFjJWv].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server.
b. Chuyển đổi mảng dữ liệu nhị phân nhận được thành một chuỗi biểu diễn hex. Mỗi byte trong mảng sẽ được chuyển đổi thành hai ký tự hex tương ứng.
Ví dụ: Nếu dữ liệu nhị phân nhận được là [72, 101, 108, 108, 111], chương trình sẽ chuyển đổi mảng này thành chuỗi hex "48656c6c6f", tương ứng với chuỗi "Hello" trong ASCII.
c. Triệu gọi phương thức submitData để gửi chuỗi biểu diễn hex đã chuyển đổi thành mảng byte trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class ChuyenSangChuoiHex {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN380";
        String qCode = "kNZFjJWv";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService byteService = (ByteService) registry.lookup("RMIByteService");
        
        byte[] data = byteService.requestData(studentCode, qCode);
        for (byte b : data) {
            System.out.print(b + " ");
        }
        System.out.println();
        
        String strHex = "";
        for (byte b : data) {
            strHex += Integer.toHexString(b);
        }
        System.out.println(strHex);
        
        byte[] res = strHex.getBytes();
        byteService.submitData(studentCode, qCode, res);
    }
}




Mã hóa Base64 - Character
[Mã câu hỏi (qCode): 5Oy8xtuo].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa:
public interface CharacterService extends Remote {
public String requestCharacter(String studentCode, String qCode) throws RemoteException;
public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
}
Trong đó:
• Interface CharacterService được viết trong package RMI.
• Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server với định dạng: "Chuỗi đầu vào".
b. Thực hiện thao tác mã hóa Base64 cho chuỗi đầu vào nhận được từ server. Mã hóa Base64 chuyển đổi chuỗi nhị phân thành định dạng văn bản ASCII bằng cách mã hóa mỗi nhóm 6 bit của chuỗi thành một ký tự.
Ví dụ: Chuỗi ban đầu "HELLO" -> Chuỗi mã hóa Base64 là: "SEVMTE8="
c. Triệu gọi phương thức submitCharacter để gửi chuỗi đã được mã hóa trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Base64;


public class MaHoaBase64 {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN269";
        String qCode = "5Oy8xtuo";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService characterService = (CharacterService) registry.lookup("RMICharacterService");
        
        String s = characterService.requestCharacter(studentCode, qCode);
        System.out.println(s);
        
        String encodedString = Base64.getEncoder().encodeToString(s.getBytes());
        characterService.submitCharacter(studentCode, qCode, encodedString);
    }
}




Giải mã Base64 - Byte
[Mã câu hỏi (qCode): OThfMprk].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân đã mã hóa dưới dạng Base64 nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server, trong đó mảng này chứa một chuỗi Base64 được mã hóa.
b. Thực hiện giải mã dữ liệu nhận được từ định dạng Base64 về dữ liệu gốc. Sử dụng giải mã Base64 để chuyển mảng byte Base64 thành mảng byte nguyên bản ban đầu.
Ví dụ: Nếu dữ liệu Base64 nhận được là chuỗi mã hóa SGVsbG8gV29ybGQ= (tương ứng với chuỗi "Hello World" trong ASCII), chương trình sẽ thực hiện giải mã để nhận được mảng dữ liệu nhị phân [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100].
c. Triệu gọi phương thức submitData để gửi mảng dữ liệu gốc đã giải mã trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


//import java.rmi.registry.Registry;
//import java.rmi.registry.LocateRegistry;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.Base64;
/**
 *
 * @author Nauh
 */
public class GiaiMaBase64 {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN290";
        String qCode = "OThfMprk";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService bs = (ByteService) registry.lookup("RMIByteService");
        
        byte[] encodedData = bs.requestData(studentCode, qCode);
        System.out.println(new String(encodedData));
        
        byte[] decodedData = Base64.getDecoder().decode(encodedData);
        System.out.println(new String(decodedData));
        
        bs.submitData(studentCode, qCode, decodedData);
    }
}


Tìm các số nguyên tố - Data
[Mã câu hỏi (qCode): xFHndckg].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu.
Giao diện từ xa:
public interface DataService extends Remote {
public Object requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, Object data) throws RemoteException;
}
Trong đó:
•        Interface DataService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa DataService được đăng ký với RegistryServer với tên là: RMIDataService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một số nguyên dương N từ server, đại diện cho giới hạn trên của khoảng cần kiểm tra.
b. Thực hiện tìm tất cả các số nguyên tố trong khoảng từ 1 đến N. Ví dụ: Với N = 10, kết quả là danh sách các số nguyên tố “2, 3, 5, 7”.
c. Triệu gọi phương thức submitData để gửi List< Integer> danh sách các số nguyên tố đã tìm được trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.ArrayList;
import java.util.List;


public class TimCacSoNguyenTo {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN290";
        String qCode = "xFHndckg";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        DataService ds = (DataService) registry.lookup("RMIDataService");
        
        int n = (int) ds.requestData(studentCode, qCode);
        System.out.println(n);
        
        List<Integer> list = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (isPrime(i)) list.add(i);
        }
        ds.submitData(studentCode, qCode, list);
    }


    private static boolean isPrime(int n) {
        if (n < 2) return false;
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
}




X - Tổ hợp kế tiếp - Data
[Mã câu hỏi (qCode): twM6kxmQ].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu.
Giao diện từ xa:
public interface DataService extends Remote {
public Object requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, Object data) throws RemoteException;
}
Trong đó:
•        Interface DataService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa DataService được đăng ký với RegistryServer với tên là: RMIDataService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một chuỗi các số nguyên.
b. Sử dụng thuật toán sinh tổ hợp kế tiếp để tìm tổ hợp kế tiếp của chuỗi số này theo thứ tự từ điển. Nếu chuỗi đã là tổ hợp lớn nhất, trả về tổ hợp nhỏ nhất (sắp xếp lại từ đầu theo thứ tự từ điển).
Ví dụ: Với chuỗi 1, 2, 3 tổ hợp kế tiếp là 1, 3, 2. Nếu chuỗi là 3, 2, 1 (tổ hợp lớn nhất), kết quả sẽ là 1, 2, 3 (tổ hợp nhỏ nhất).
c. Triệu gọi phương thức submitData để gửi chuỗi chứa tổ hợp kế tiếp đã tìm được trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


import RMI.DataService;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Arrays;


public class ToHopKeTiep {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        DataService dataService = (DataService) registry.lookup("RMIDataService");
        
        String studentCode = "B21DCCN404";
        String qCode = "twM6kxmQ";
        
        String receivedData = (String) dataService.requestData(studentCode, qCode);
        System.out.println(receivedData);
        
        int[] numbers = Arrays.stream(receivedData.split(", "))
                .mapToInt(Integer::parseInt)
                .toArray();
        
        findNextPermutation(numbers);
        String res = Arrays.toString(numbers).replaceAll("[\\[\\] ]", "");
        System.out.println(res);
        
        
        dataService.submitData(studentCode, qCode, res);
        
    }


    private static void findNextPermutation(int[] numbers) {
        int n = numbers.length;
        int i = n - 2;
        
        while (i >= 0 && numbers[i] >= numbers[i+1]) {
            i--;
        }
        
        if(i>=0) {
            int j = n-1;
            while (numbers[j] <= numbers[i]) {
                j--;
            }
            swap(numbers, i, j);
        }
        
        reverse(numbers, i+1, n-1);
    }
    
    private static void swap(int [] a, int i, int j) {
        int tmp = a[j];
        a[j] = a[i];
        a[i] = tmp;
    }
    
    private static void reverse(int [] a, int start, int end) {
        while (start < end) {
            swap(a, start, end);
            start++;
            end--; 
        }
    }
}


X - Sinh tổ hợp - Data
[Mã câu hỏi (qCode): CtDadScb].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu.
Giao diện từ xa:
public interface DataService extends Remote {
public Object requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, Object data) throws RemoteException;
}
Trong đó:
•        Interface DataService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa DataService được đăng ký với RegistryServer với tên là: RMIDataService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một chuỗi gồm tập hợp số nguyên và một số nguyên K từ server với định dạng: “mảng; số nguyên K”.
b. Sử dụng thuật toán sinh tổ hợp để tạo ra tất cả các tổ hợp kích thước K của tập hợp đã cho. Kết quả trả về là danh sách các tổ hợp con có K phần tử.
Ví dụ: Với tập hợp [1, 2, 3, 4] và K = 2, kết quả là danh sách các tổ hợp [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].
c. Triệu gọi phương thức submitData để gửi List<List<Integer>> chứa danh sách các tổ hợp đã sinh được trở lại server.
d. Kết thúc chương trình client.


Code:




package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.ArrayList;
import java.util.List;


public class SinhToHop {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN800";
        String qCode = "CtDadScb";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        DataService dataService = (DataService) registry.lookup("RMIDataService");
        
        String receivedString = (String) dataService.requestData(studentCode, qCode);
        System.out.println(receivedString);
        
        String[] parts = receivedString.split(";");
        String[] numbers = parts[0].split(",");
        int k = Integer.parseInt(parts[1].trim());
        
        List<Integer> array = new ArrayList<>();
        for (String number : numbers) {
            array.add(Integer.parseInt(number.trim()));
        }
        
        List<List<Integer>> res = new ArrayList<>();
        Try(res, new ArrayList<>(), array, k, 0);
        System.out.println(res);
      
        dataService.submitData(studentCode, qCode, res);
        
    }


    private static void Try(List<List<Integer>> res, ArrayList<Integer> tempList, List<Integer> array, int k, int start) {
        if (tempList.size() == k) {
            res.add(new ArrayList<>(tempList));
            return;
        }
        
        for (int i = start; i < array.size(); i++) {
            tempList.add(array.get(i));
            Try(res, tempList, array, k, i + 1);
            tempList.removeLast();
        }
    }


    }
Cập nhật giá trị khuyến mãi - Object
[Mã câu hỏi (qCode): QDU497le].  Một chương trình (tạm gọi là RMI Server) cung cấp các mã khuyến mãi sản phẩm ngẫu nhiên cho sinh viên, được mô tả như sau:
•        Giao diện từ xa
    public interface ObjectService extends Remote {
        public Serializable requestObject(String studentCode, String qAlias) throws RemoteException;


        public void submitObject(String studentCode, String qAlias, Serializable object) throws RemoteException;
    }
•        Lớp ProductX gồm các thuộc tính id String, code String, discountCode String, discount int.
o        Một hàm khởi dựng với đầy đủ các thuộc tính liệt kê ở trên
o        Trường dữ liệu: private static final long serialVersionUID = 20171107; 
•        Đối tượng triệu gọi từ xa được đăng ký RegistryServer với tên: RMIObjectService
•        Tất cả các lớp được viết trong package RMI


Yêu cầu là xây dựng một chương trình client thực hiện các tương tác với hệ thống phần mềm ở trên theo kịch bản dưới đây:
1.          Triệu gọi phương thức từ xa requestObject từ RMI Server với tham số đầu vào là mã sinh viên, mã câu để nhận về đối tượng ProductX
2.    Nhận về đối tượng ProductX từ RMI Server với giá trị ban đầu đã được thiết lập. Tính tổng các chữ số nằm trong chuỗi mã giảm giá (discountCode) để ra giá trị được khuyến mãi của sản phẩm và cập nhật giá trị của khuyến mãi (discount)
3.        Triệu gọi phương thức từ xa submitObject với tham số đầu vào là đối tượng Product đã được cập nhật đầy đủ thông tin giá trị khuyến mãi
4.        Kết thúc chương trình


Code:


package RMI;


import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;


public class CapNhatGiaTriKhuyenMai {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN404";
        String qAlias = "QDU497le";
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ObjectService os = (ObjectService) registry.lookup("RMIObjectService");
        
        ProductX productX = (ProductX) os.requestObject(studentCode, qAlias);
        System.out.println(productX);
        
        int discount = 0;
        String discountString = productX.getDiscountCode();
        for(char c : discountString.toCharArray()) {
            if (Character.isDigit(c)) {
                discount += Character.getNumericValue(c);
            }
        }
        System.out.println(discount);
        productX.setDiscount(discount);
        os.submitObject(studentCode, qAlias, productX);
    }
}


Chuẩn hóa đối tượng sản phẩm - Object
[Mã câu hỏi (qCode): oCpVpCeX].  Một chương trình (tạm gọi là RMI server) cung cấp giao diện cho phép triệu gọi từ xa với thông tin như sau:
-        Giao diện từ xa
    public interface ObjectService extends Remote {
        public Serializable requestObject(String studentCode, String qAlias) throws RemoteException;


        public void submitObject(String studentCode, String qAlias, Serializable object) throws RemoteException;
    }
-        Lớp Product gồm các thông tin: id String, code String, importPrice double, exportPrice double.
    Trường dữ liệu: private static final long serialVersionUID = 20151107L;
    02 hàm khởi dựng 
        public Product()
        public Product(int String, String code,double ImportPrice, double ExportPrice)
Trong đó:
-        interface ObjectService và lớp Product được viết trong package RMI
-        Đối tượng cài đặt giao diện từ xa ObjectService được đăng ký với RegistryServer: RMIObjectService


Yêu cầu yêu cầu viết chương trình tại máy trạm (RMI client) thực hiện chuẩn hóa sản phẩm theo thứ tự:
a.        Triệu gọi phương thức requestObject để lấy về đối tượng sản phẩm cần chuẩn hóa.
b.        Thực hiện chuẩn hóa đối tượng nhận được theo nguyên tắc:
        - Chuyển mã sản phẩm thành in hoa.
        - Cập nhật giá xuất (exportPrice) bằng giá nhập (importPrice) + 20%


c.  Triệu gọi phương thức submitObject để gửi dữ liệu đã chuẩn hóa
d.  Kết thúc chương trình client


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.AccessException;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;


public class ChuanHoaProduct {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN290";
        String qCode = "oCpVpCeX";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ObjectService os = (ObjectService) registry.lookup("RMIObjectService");
        
        Product product = (Product) os.requestObject(studentCode, qCode);
        System.out.println(product);
        
        product.setCode(product.getCode().toUpperCase());
        System.out.println(product.getCode());
        product.setExportPrice((double) product.getImportPrice() * 1.2);
        
        os.submitObject(studentCode, qCode, product);
    }
}




Đếm tần số xuất hiện của mỗi ký tự trong chuỗi và tạo chuỗi kết quả - Character
[Mã câu hỏi (qCode): 0zhGpb02].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa:
public interface CharacterService extends Remote {
public String requestCharacter(String studentCode, String qCode) throws RemoteException;
public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
}
Trong đó:
•        Interface CharacterService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server với định dạng: "Chuỗi đầu vào".
b. Thực hiện đếm tần số xuất hiện của mỗi ký tự trong chuỗi đầu vào và tạo ra chuỗi kết quả theo định dạng <Ký tự><Số lần xuất hiện>, sắp xếp theo thứ tự xuất hiện của các ký tự trong chuỗi.
Ví dụ: Chuỗi đầu vào "AAABBC" -> Kết quả: "A3B2C1".
c. Triệu gọi phương thức submitCharacter để gửi chuỗi kết quả trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.LinkedHashMap;
import java.util.Map;


public class SoLanXuatHienKyTu {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN290";
        String qCode = "0zhGpb02";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService cs = (CharacterService) registry.lookup("RMICharacterService");
        
        String s = cs.requestCharacter(studentCode, qCode);
        System.out.println(s);
        
        Map<Character, Integer> map = new LinkedHashMap<>();
        for(Character i : s.toCharArray()) {
            map.put(i, map.getOrDefault(i, 0) + 1);
        }
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            sb.append(entry.getKey()).append(entry.getValue());
        }
        System.out.println(sb.toString());
        
        cs.submitCharacter(studentCode, qCode, sb.toString());
    }
}


Đếm tần số xuất hiện của mỗi ký tự trong chuỗi và tạo danh sách kết quả - Character
[Mã câu hỏi (qCode): 0N6vnNyi].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa:
public interface CharacterService extends Remote {
public String requestCharacter(String studentCode, String qCode) throws RemoteException;
public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
}
Trong đó:
• Interface CharacterService được viết trong package RMI.
• Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server với định dạng: "Chuỗi văn bản đầu vào".
b. Thực hiện thao tác đếm tần số xuất hiện của từng ký tự trong chuỗi đầu vào. Kết quả trả về là danh sách các ký tự kèm theo số lần xuất hiện của mỗi ký tự.
Ví dụ: Chuỗi ban đầu "Hello world" -> Kết quả đếm tần số ký tự: {"H": 1, "e": 1, "l": 3, "o": 2, " ": 1, "w": 1, "r": 1, "d": 1}.
c. Triệu gọi phương thức submitCharacter để gửi kết quả đếm tần số ký tự trở lại server dưới dạng chuỗi kết quả đã được định dạng.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.LinkedHashMap;
import java.util.Map;


public class SoLanXuatHienKyTuDS {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN680";
        String qCode = "0N6vnNyi";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService characterService = (CharacterService) registry.lookup("RMICharacterService");
        
        String s = characterService.requestCharacter(studentCode, qCode);
        System.out.println(s);
        
        Map<Character, Integer> map = new LinkedHashMap<>();
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        System.out.println(map);
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            sb.append("\"").append(entry.getKey()).append("\"").append(": ").append(entry.getValue()).append(", ");
        }
        String res = sb.substring(0, sb.toString().length() - 2);
        res += "}";
        System.out.println(res);
        characterService.submitCharacter(studentCode, qCode, res);
    }
}




Mã hóa Caesar - Byte
[Mã câu hỏi (qCode): kznyzKHp].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server, đại diện cho một chuỗi văn bản ASCII.
b. Thực hiện mã hóa Caesar cho mảng dữ liệu nhị phân bằng cách dịch chuyển mỗi byte trong mảng đi một số bước cố định trong bảng mã ASCII. Số bước dịch chuyển là số ký tự ASCII trong mảng dữ liệu.
    Ví dụ: Nếu dữ liệu nhị phân nhận được là [72, 101, 108, 108, 111] (tương ứng với chuỗi "Hello"), chương trình sẽ thực hiện mã hóa Caesar với độ dịch là 5. Kết quả mã hóa là mảng [77, 108, 113, 113, 116], tương ứng với chuỗi "Mlqqt".
c. Triệu gọi phương thức submitData để gửi mảng dữ liệu đã được mã hóa bằng Caesar trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class MaHoaCaesar {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN096";
        String qCode = "kznyzKHp";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService byteService = (ByteService) registry.lookup("RMIByteService");
        
        byte[] data = byteService.requestData(studentCode, qCode);
        for (byte b : data) {
            System.out.print(b + " ");
        }
        System.out.println();
        
        int shift = data.length;
        byte[] encodedData = new byte[data.length];
        for (int i = 0; i < data.length; i++) {
            encodedData[i] = (byte) (data[i] + shift);
        }
        
        byteService.submitData(studentCode, qCode, encodedData);
    }
}


Giải mã Caesar - Character
[Mã câu hỏi (qCode): xy0fvP5j].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi. Cụ thể:
Giao diện từ xa:
    public interface CharacterService extends Remote {
        public String requestCharacter(String studentCode, String qCode) throws RemoteException;
        public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
    }
Trong đó:
•        Interface CharacterService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server. 
b. Thực hiện thao tác giải mã Caesar (mã hóa chuỗi bằng cách dịch từng ký tự đi một số lượng vị trí nhất định). Biết rằng giá trị dịch đúng bằng kích thước của chuỗi chia lấy dư cho 7.
c. Triệu gọi phương thức submitCharacter để gửi chuỗi đã được giải mã trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class GiaiMaCaesar {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN656";
        String qCode = "xy0fvP5j";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService characterService = (CharacterService) registry.lookup("RMICharacterService");
        
        String inputString = characterService.requestCharacter(studentCode, qCode);
        System.out.println(inputString);
        int shift = inputString.length() % 7;
        
        String res = "";
        for (char c : inputString.toCharArray()) {
            if (Character.isUpperCase(c)) {
                res += (char) ((c - shift - 'A' + 26) % 26 + 'A');
            }
            else res += (char) ((c - shift - 'a' + 26) % 26 + 'a');
        }
        characterService.submitCharacter(studentCode, qCode, res);
    }
}




Mã hóa XOR cho mảng dữ liệu nhị phân - Byte
[Mã câu hỏi (qCode): 1UoeVUyZ].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server, đại diện cho một chuỗi văn bản ASCII.
b. Thực hiện mã hóa XOR cho mảng dữ liệu nhị phân bằng cách sử dụng một khóa là chuỗi "PTIT". Thực hiện phép XOR trên từng byte trong mảng dữ liệu với byte tương ứng trong khóa (khóa sẽ được lặp lại để khớp với độ dài của mảng dữ liệu).
Ví dụ: Nếu dữ liệu nhị phân nhận được là [72, 101, 108, 108, 111] (tương ứng với chuỗi "Hello"), và khóa là "PTIT", chương trình sẽ thực hiện mã hóa như sau:
•        Chuyển khóa "PTIT" thành mảng byte [80, 84, 73, 84].
•        Lặp lại khóa để khớp độ dài dữ liệu: [80, 84, 73, 84, 80].
•        Thực hiện phép XOR trên từng byte của dữ liệu với khóa:
•        Kết quả mã hóa là mảng [24, 49, 37, 56, 63].
c. Triệu gọi phương thức submitData để gửi mảng dữ liệu đã được mã hóa bằng XOR trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class MaHoaXORChoMangNhiPhan {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN626";
        String qCode = "1UoeVUyZ";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService byteService = (ByteService) registry.lookup("RMIByteService");
        
        byte[] data = byteService.requestData(studentCode, qCode);
        for (byte b : data) {
            System.out.print(b + " ");
        }
        System.out.println();
        
        String key = "PTIT";
        byte[] keyBytes = key.getBytes();
        byte[] encodedData = new byte[data.length];
        for (int i = 0; i < data.length; i++) {
            encodedData[i] = (byte) (data[i] ^ keyBytes[i % keyBytes.length]);
        }
        
        byteService.submitData(studentCode, qCode, encodedData);
        
    }
}




Mã hóa XOR cho chuỗi - Character
[Mã câu hỏi (qCode): 6zekhBAs].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa: 
public interface CharacterService extends Remote { 
public String requestCharacter(String studentCode, tring qCode) throws RemoteException; 
public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException; 
}
Trong đó: 
• Interface CharacterService được viết trong package RMI. 
• Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server: a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server với định dạng: "Khóa XOR;Chuỗi đầu vào". 
b. Thực hiện thao tác mã hóa XOR cho chuỗi đầu vào với khóa XOR nhận được từ server. Mã hóa XOR thực hiện bằng cách áp dụng phép XOR trên từng ký tự trong chuỗi đầu vào và ký tự tương ứng trong khóa (khóa được lặp lại để khớp độ dài chuỗi đầu vào). 
Ví dụ: Chuỗi ban đầu "A;HELLO" -> Khóa "A" -> chuỗi mã hóa là: "IFMMN"
c. Triệu gọi phương thức submitCharacter để gửi chuỗi đã được mã hóa trở lại server. 
d. Kết thúc chương trình client.


Code:


package RMI;


import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;


public class MaHoaXOR {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService cs = (CharacterService) registry.lookup("RMICharacterService");
        
        String studentCode = "B21DCCN404";
        String qCode = "6zekhBAs";
        
        String s = cs.requestCharacter(studentCode, qCode);
        System.out.println(s);
        
        char xorKey = s.charAt(0);
        System.out.println(xorKey);
        
        String inputString = s.substring(2);
        System.out.println(inputString);
        
        StringBuilder encodedString = new StringBuilder();
        for (int i = 0; i < inputString.length(); i++) {
            char c = (char) ((inputString.charAt(i) ^ xorKey));
            encodedString.append(c);
        }
        System.out.println(encodedString.toString());
 
        cs.submitCharacter(studentCode, qCode, encodedString.toString());
    }
}


Mã hóa URL - Character
[Mã câu hỏi (qCode): dKG0aOvX].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa:
public interface CharacterService extends Remote {
public String requestCharacter(String studentCode, String qCode) throws RemoteException;
public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
}
Trong đó:
• Interface CharacterService được viết trong package RMI.
• Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server với định dạng: "Chuỗi đầu vào".
b. Thực hiện thao tác mã hóa URL (URL Encoding) cho chuỗi đầu vào nhận được từ server. Mã hóa URL chuyển đổi các ký tự đặc biệt thành định dạng URL an toàn bằng cách thay thế các ký tự đó bằng ký hiệu phần trăm (%) và mã ASCII của chúng.
Ví dụ: Chuỗi ban đầu "Hello World!" -> Chuỗi mã hóa URL là: "Hello%20World%21"
c. Triệu gọi phương thức submitCharacter để gửi chuỗi đã được mã hóa trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class MaHoaURL {
    public static void main(String[] args) throws RemoteException, NotBoundException, UnsupportedEncodingException {
        String studentCode = "B21DCCN263";
        String qCode = "dKG0aOvX";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService characterService = (CharacterService) registry.lookup("RMICharacterService");
        
        String inputString = characterService.requestCharacter(studentCode, qCode);
        System.out.println(inputString);
        
        String res = URLEncoder.encode(inputString, "UTF-8");
        characterService.submitCharacter(studentCode, qCode, res);
    }
}




Mã hóa Vigenère - Character
[Mã câu hỏi (qCode): qBgCoIgp].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa:
    public interface CharacterService extends Remote {
        public String requestCharacter(String studentCode, String qCode) throws RemoteException;
        public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
    }
Trong đó:
•        Interface CharacterService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server với định dạng: "Từ khóa;Chuỗi đầu vào"
b. Thực hiện thao tác mã hóa Vigenère cho chuỗi nhận được. Biết rằng, mã hóa Vigenère thực hiện mã hóa mỗi ký tự trong chuỗi đầu vào được dịch đi một khoảng bằng với vị trí tương ứng của ký tự trong từ khóa. (Từ khóa được lặp lại để khớp với độ dài của chuỗi)
Ví dụ: chuỗi ban đầu "PTIT;HELLO" -> từ khóa "PTIT" và chuỗi mã hóa là: "WXTED"
c. Triệu gọi phương thức submitCharacter để gửi chuỗi đã được mã hóa trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class MaHoaVigenere {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN485";
        String qCode = "qBgCoIgp";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService characterService = (CharacterService) registry.lookup("RMICharacterService");
        
        String inpuString = characterService.requestCharacter(studentCode, qCode);
        System.out.println(inpuString);
        
        String[] parts = inpuString.split(";");
        String keyword = parts[0];
        String dataString = parts[1];
        
        StringBuilder encodedString = new StringBuilder();
        int keywordLength = keyword.length();
        for (int i = 0; i < dataString.length(); i++) {
            char inputChar = dataString.charAt(i);
            char keywordChar = keyword.charAt(i % keywordLength);
            char encodedChar = (char) (((inputChar - 'a') + (keywordChar - 'a'))  % 26 + 'a');
            encodedString.append(encodedChar);
        }
        
        characterService.submitCharacter(studentCode, qCode, encodedString.toString());
    }
}




Tìm phần tử lớn thứ K trong mảng với K là phần tử cuối cùng của mảng - Byte
[Mã câu hỏi (qCode): 6epmUABK].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server, cùng với một số nguyên K, đại diện cho thứ tự phần tử cần tìm.
b. Tìm phần tử lớn thứ K trong mảng byte[] với K là phần tử cuối cùng của mảng.
Ví dụ: Nếu mảng dữ liệu nhận được là [3, 1, 5, 12, 2, 11, 3], giá trị K = 3, chương trình sẽ tìm phần tử lớn thứ ba -> Kết quả là 5.
c. Triệu gọi phương thức submitData để gửi mảng byte gồm phần tử lớn thứ K và vị trí của K trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


public class PhanTuLonThuK {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN680";
        String qCode = "6epmUABK";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService byteService = (ByteService) registry.lookup("RMIByteService");
        
        byte[] data = byteService.requestData(studentCode, qCode);
        List<Integer> list = new ArrayList<>();
        
        for (byte b : data) {
            System.out.print(b + " ");
            list.add((int) b);
        }


        list.removeLast(); // xoa phan tu cuoi
        System.out.println();
        Collections.sort(list, Collections.reverseOrder());
        int k = data[data.length - 1];
        System.out.println(k);
        System.out.println(list);
        int kthLargest = list.get(k - 1);
        System.out.println(kthLargest);
        
        int kthPosition = 0;
        for (int i = 0 ;i < data.length; i++) {
            if (kthLargest == (int) data[i]) {
                kthPosition = i + 1;
                break;
            }
        }
        System.out.println(kthPosition);
        
        byte[] res = new byte[] {(byte) kthLargest, (byte) kthPosition};
        byteService.submitData(studentCode, qCode, res);
    }
}






Nén RLE - Byte
[Mã câu hỏi (qCode): jqDIWz1L].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu byte nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu byte từ server, đại diện cho một chuỗi dữ liệu byte tổng quát.
b. Thực hiện nén dữ liệu sử dụng thuật toán Run-Length Encoding (RLE) bằng cách ghi nhận mỗi byte và số lần lặp liên tiếp của nó. Kết quả nén là một mảng mới biểu diễn các cặp (byte, số lần lặp).
Ví dụ: Nếu dữ liệu byte nhận được là [10, 10, 10, 20, 20, 30, 30, 30, 30], chương trình sẽ thực hiện nén RLE như sau:
    Kết quả nén RLE là mảng [10, 3, 20, 2, 30, 4].
c. Triệu gọi phương thức submitData để gửi mảng dữ liệu đã được nén RLE trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.ArrayList;
import java.util.List;


public class NenRLE {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN800";
        String qCode = "jqDIWz1L";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService byteService = (ByteService) registry.lookup("RMIByteService");
        
        byte[] data = byteService.requestData(studentCode, qCode);
        byte[] compressedData = rle(data);
        
        
        byteService.submitData(studentCode, qCode, compressedData);
    }


    private static byte[] rle(byte[] data) {
        List<Byte> list = new ArrayList<>();
        int i = 0;
        while (i < data.length) {
            byte currentByte = data[i];
            int cnt = 1;
            
            while (i + 1 < data.length && data[i + 1] == currentByte) {
                cnt++;
                i++;
            }
            i++;
            list.add(currentByte);
            list.add((byte) cnt);
        }
        byte[] compressed = new byte[list.size()];
        for (int j = 0; j < list.size(); j++) {
            compressed[j] = list.get(j);
        }
        return compressed;
    }
}


Tính lương cho nhân viên - Object
[Mã câu hỏi (qCode): 9SqCx8ED].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý thông tin nhân viên. Chương trình sẽ ngẫu nhiên tạo ra đối tượng Employee với các giá trị ban đầu và cung cấp cho RMI client như sau:
Giao diện từ xa:
public interface ObjectService extends Remote {
    public Serializable requestObject(String studentCode, String qCode) throws RemoteException;
    public void submitObject(String studentCode, String qCode, Serializable object) throws RemoteException;
}
Lớp Employee gồm các thuộc tính: id String, name String, baseSalary double, experienceYears int, finalSalary double.
Trường dữ liệu: private static final long serialVersionUID = 20241119L;
02 hàm khởi dựng: 
public Employee() 
public Employee(String id, String name, double baseSalary, int experienceYears)
Trong đó:
•        Interface ObjectService và lớp Employee được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ObjectService được đăng ký với RegistryServer với tên là: RMIObjectService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với đối tượng nhân viên được nhận từ RMI Server:
a. Triệu gọi phương thức requestObject với tham số đầu vào là mã sinh viên và mã câu hỏi để nhận đối tượng Employee ngẫu nhiên từ server.
b. Tính toán finalSalary dựa trên baseSalary, experienceYears, và áp dụng thuật toán xử lý số phức tạp để tạo hệ số điều chỉnh, yêu cầu sinh viên phải thao tác và xử lý experienceYears như sau:
•        Tách experienceYears thành tổng các chữ số (ví dụ, 14 sẽ thành 1 + 4 = 5).
•        Tính số lượng ước số nguyên của experienceYears (ví dụ, nếu experienceYears là 12, các ước số là 1, 2, 3, 4, 6, 12, nên có 6 ước số).
•        Xác định hệ số điều chỉnh factor dựa trên công thức sau: factor = (Số năm làm việc + tổng các chữ số + số lượng ước số) / 100.0
•        Tính finalSalary theo công thức: finalSalary = baseSalary * (1 + factor)
c. Cập nhật giá trị finalSalary trong đối tượng Employee.
d. Triệu gọi phương thức submitObject để gửi đối tượng Employee đã được xử lý trở lại server.
e. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */


import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class CapNhatLuong {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN800";
        String qCode = "9SqCx8ED";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ObjectService os = (ObjectService) registry.lookup("RMIObjectService");
        
        Employee employee = (Employee) os.requestObject(studentCode, qCode);
        System.out.println(employee);
        
        int experienceYears = employee.getExperienceYears();
        int n = experienceYears;
        int sumNumbers = 0;
        int us = 0;
        while (n > 0) {
            int x = n % 10;
            sumNumbers += x;
            n /= 10;
        }
        
        for (int i = 1; i <= experienceYears; i++) {
            if (experienceYears % i == 0) us++;
        }
        
        double factor = (experienceYears + sumNumbers + us) / 100.0;
        double finalSalary = employee.getBaseSalary() * (1 + factor);
        employee.setFinalSalary(finalSalary);
        
        os.submitObject(studentCode, qCode, employee);
    }
}


Thập phân -> La mã - Character
[Mã câu hỏi (qCode): Tb7xyRU3].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa:
public interface CharacterService extends Remote {
public String requestCharacter(String studentCode, String qCode) throws RemoteException;
public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
}
Trong đó:
• Interface CharacterService được viết trong package RMI.
• Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server với định dạng: "Số thập phân đầu vào".
b. Thực hiện chuyển đổi số thập phân nhận được thành chuỗi số La Mã (Roman).
Quy tắc chuyển đổi:
    Các ký tự La Mã chính bao gồm: I=1, V=5, X=10, L=50, C=100, D=500, M=1000.
    Ví dụ: 58 -> "LVIII".
c. Triệu gọi phương thức submitCharacter để gửi chuỗi số La Mã đã chuyển đổi trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class ChuoiSoLaMa {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN344";
        String qCode = "Tb7xyRU3";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService cs = (CharacterService) registry.lookup("RMICharacterService");
        
        String s = cs.requestCharacter(studentCode, qCode);
        int inputDecimal = Integer.parseInt(s);
        System.out.println(inputDecimal);
        
        String romanRes = convertToRoman(inputDecimal);
        cs.submitCharacter(studentCode, qCode, romanRes);
    }


    private static String convertToRoman(int inputDecimal) {
        int[] decimalValues = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] romanSymbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        
        StringBuilder roman = new StringBuilder();
        for (int i = 0; i < decimalValues.length; i++) {
            while (inputDecimal >= decimalValues[i]) {
                inputDecimal -= decimalValues[i];
                roman.append(romanSymbols[i]);
            }
        }
        return roman.toString();
    }
}


La mã -> Thập phân - Character
[Mã câu hỏi (qCode): 8PYw67Fg].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa:
public interface CharacterService extends Remote {
public String requestCharacter(String studentCode, String qCode) throws RemoteException;
public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
}
Trong đó:
• Interface CharacterService được viết trong package RMI.
• Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi ngẫu nhiên từ server với định dạng: "Chuỗi số La Mã đầu vào".
b. Thực hiện chuyển đổi chuỗi số La Mã nhận được thành số thập phân (Decimal).
Quy tắc chuyển đổi: Các ký tự La Mã chính bao gồm: I=1, V=5, X=10, L=50, C=100, D=500, M=1000.
    Ví dụ: "MCMXCIV" -> 1994.
c. Triệu gọi phương thức submitCharacter để gửi số thập phân đã chuyển đổi trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class ChuyenLaMaSangThapPhan {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN032";
        String qCode = "8PYw67Fg";
    
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService characterService = (CharacterService) registry.lookup("RMICharacterService");
        
        String s = characterService.requestCharacter(studentCode, qCode);
        System.out.println(s);
        
        int decimalValue = convertRomanToDecimal(s);
        System.out.println(decimalValue);
        characterService.submitCharacter(studentCode, qCode, String.valueOf(decimalValue));
    }


    private static int toDec(char c) {
        if (c == 'I') return 1;
        if (c == 'V') return 5;
        if (c == 'X') return 10;
        if (c == 'L') return 50;
        if (c == 'C') return 100;
        if (c == 'D') return 500;
        if (c == 'M') return 1000;
        return 0;
    }
    
    private static int convertRomanToDecimal(String s) {
        int res = 0;
        int prevValue = 0;
        
        for (int i = s.length() - 1; i >=0; i--) {
            char currentChar = s.charAt(i);
            int currentValue = toDec(currentChar);
            
            if (currentValue < prevValue) res -= currentValue;
            else res += currentValue;
            prevValue = currentValue;
        }
        return res;
    }
}






Cập nhật mã và tên sinh viên - Object
[Mã câu hỏi (qCode): YUxGuCPw].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý thông tin sinh viên trong hệ thống quản lý giáo dục. Chương trình sẽ ngẫu nhiên tạo ra đối tượng Student với các giá trị ban đầu và cung cấp cho RMI client như sau:


    Giao diện từ xa:
public interface ObjectService extends Remote {
    public Serializable requestObject(String studentCode, String qCode) throws RemoteException;
    public void submitObject(String studentCode, String qCode, Serializable object) throws RemoteException;
}
Lớp Student gồm các thuộc tính: id String, name String, enrollmentYear int, code String.
Trường dữ liệu: private static final long serialVersionUID = 20241130L;
02 hàm khởi dựng:
    public Student()
    public Student(String id, String name, int enrollmentYear)
Trong đó:
    Interface ObjectService và lớp Student được viết trong package RMI.
    Đối tượng cài đặt giao diện từ xa ObjectService được đăng ký với RegistryServer: RMIObjectService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với đối tượng sinh viên được nhận từ RMI Server:
a. Triệu gọi phương thức requestObject để nhận đối tượng Student ngẫu nhiên từ server.
b. Thực hiện 
Tạo mã code cho sinh viên dựa trên các quy tắc sau:
•        Bắt đầu bằng ký tự "B".
•        Kế đến là hai chữ số cuối của enrollmentYear.
•        Sau đó là TÊN của sinh viên, tất cả các ký tự của tên viết in hoa.
•        Kết thúc với các chữ cái đầu tiên của Họ và Họ lót, đều viết in hoa.
Ví dụ: Nếu sinh viên có tên là "Nguyen Van Tuan", năm nhập học là 2022, mã code sẽ là "B22TUAN_NV".
Chuẩn hóa tên (name) theo quy tắc:
•        Chữ cái đầu tiên của Tên, Họ, và Tên lót phải viết hoa, các chữ cái khác viết thường.
•        Ví dụ: Nếu name ban đầu là "nguYEn van tAi tUAN", sau khi chuẩn hóa sẽ trở thành "Nguyen Van Tai Tuan".
c. Cập nhật giá trị mã (code) và tên (name) trong đối tượng Student và 
d. Triệu gọi phương thức submitObject để gửi đối tượng Student đã được xử lý trở lại server.
e. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;


public class Ma_Ten_SinhVien {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN344";
        String qCode = "YUxGuCPw";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);;
        ObjectService objectService = (ObjectService) registry.lookup("RMIObjectService");
        
        Student student = (Student) objectService.requestObject(studentCode, qCode);
        System.out.println(student);
        
        String code = "B" + String.valueOf(student.getEnrollmentYear()).substring(2, 4);
        String name = student.getName();
        String[] names = name.trim().split("\\s+");
        String lastName = names[names.length - 1];
        code += lastName.toUpperCase() + "_";
        for (int i = 0; i < names.length - 1; i++) {
            code += (names[i].charAt(0) + "").toUpperCase();
        }
        System.out.println(code);
        student.setCode(code.trim());
        
        StringBuilder newName = new StringBuilder();
        for (int i = 0; i < names.length; i++) {
            newName.append((names[i].charAt(0) + "").toUpperCase()).append(names[i].substring(1).toLowerCase());
            if (i != names.length - 1) newName.append(" ");
        }
        
        System.out.println(newName.toString());
        student.setName(newName.toString());
        System.out.println(student);
        
        objectService.submitObject(studentCode, qCode, student);
    }
}


Phân chia chẵn lẻ - Byte
[Mã câu hỏi (qCode): Ms0yOvZv].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server.
b. Thực hiện phân chia mảng byte[] nhận được thành hai phần: phần đầu chứa các byte có giá trị chẵn và phần sau chứa các byte có giá trị lẻ, duy trì thứ tự xuất hiện của các phần tử trong từng nhóm.
Ví dụ: Nếu mảng dữ liệu nhận được là [1, 2, 3, 4, 5], sau khi phân chia chẵn-lẻ, mảng kết quả sẽ là [2, 4, 1, 3, 5] (tất cả phần tử chẵn được đặt trước, theo sau là tất cả phần tử lẻ).
c. Triệu gọi phương thức submitData để gửi mảng byte[] đã được phân chia chẵn-lẻ trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.ArrayList;
import java.util.List;


public class PhanChiaChanLe {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN032";
        String qCode = "Ms0yOvZv";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService bs = (ByteService) registry.lookup("RMIByteService");
        
        byte[] data = bs.requestData(studentCode, qCode);
        for (byte b : data) {
            System.out.print(b + " ");
        }
        System.out.println();
        
        byte[] res = seperateEvenOdd(data);
        
        bs.submitData(studentCode, qCode, res);
    }


    private static byte[] seperateEvenOdd(byte[] data) {
        List<Byte> evenList = new ArrayList<>();
        List<Byte> oddList = new ArrayList<>();
        
        for (byte b : data) {
            if (b % 2 == 0) {
                evenList.add(b);
            }
            else oddList.add(b);
        }
        
        byte[] res = new byte[data.length];
        int i = 0;
        for (byte b : evenList) {
            res[i++] = b;
        }
        for (byte b : oddList) {
            res[i++] = b;
        }
        return  res;
    }
}


Xếp đồng xu - Data
[Mã câu hỏi (qCode): fW3Liakj].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu.
Giao diện từ xa:
public interface DataService extends Remote {
public Object requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, Object data) throws RemoteException;
}
Trong đó:
•        Interface DataService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa DataService được đăng ký với RegistryServer với tên là: RMIDataService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một số nguyên dương amount từ server, đại diện cho số tiền cần đạt được.
b. Sử dụng thuật toán xếp đồng xu với các mệnh giá cố định [1, 2, 5, 10] để xác định số lượng đồng xu tối thiểu cần thiết để đạt được số tiền amount. Nếu không thể đạt được số tiền đó với các mệnh giá hiện có, trả về -1.
Ví dụ: Với amount = 18 và mệnh giá đồng xu cố định [1, 2, 5, 10], kết quả là 4 (18 = 10 + 5 + 2 + 1). Chuỗi cần gửi lên server là: 4; 10,5,2,1
c. Triệu gọi phương thức submitData để gửi chuỗi chứa kết quả số lượng đồng xu tối thiểu và giá trị các đồng xu tương ứng  trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.ArrayList;
import java.util.List;


public class XepDongXu {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN032";
        String qCode = "fW3Liakj";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        DataService dataService = (DataService) registry.lookup("RMIDataService");
        
        int amount = (int) dataService.requestData(studentCode, qCode);
        System.out.println(amount);
        String res = calculateMinCoins(amount);
        System.out.println(res);
        
        dataService.submitData(studentCode, qCode, res);
    }


    private static String calculateMinCoins(int amount) {
        int[] coins = {10, 5, 2, 1};
        List<Integer> usedCoins = new ArrayList<>();
        
        for (int coin : coins) {
            while (amount >= coin) {
                amount -= coin;
                usedCoins.add(coin);
            }
        }
        
        StringBuilder res = new StringBuilder();
        res.append(usedCoins.size()).append("; ");
        for (int i = 0; i < usedCoins.size(); i++) {
            res.append(usedCoins.get(i));
            if (i != usedCoins.size() - 1) res.append(",");
        }
        return res.toString();
    }
}


Số chính phương - Data
[Mã câu hỏi (qCode): KgkSDthR].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu.
Giao diện từ xa:
public interface DataService extends Remote {
public Object requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, Object data) throws RemoteException;
}
Trong đó:
•        Interface DataService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa DataService được đăng ký với RegistryServer với tên là: RMIDataService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một số nguyên dương N từ server.
b. Xác định tất cả các số chính phương nhỏ hơn N. Kết quả trả về là danh sách các số chính phương thỏa mãn yêu cầu.
Ví dụ: Với N = 20, kết quả là [1, 4, 9, 16].
c. Triệu gọi phương thức submitData để gửi đối tượng List<Integer> danh sách các số chính phương đã tìm được trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.ArrayList;
import java.util.List;


public class SoChinhPhuong {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN380";
        String qCode = "KgkSDthR";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        DataService dataService = (DataService) registry.lookup("RMIDataService");
        
        int n = (int) dataService.requestData(studentCode, qCode);
        System.out.println(n);
        
        List<Integer> list = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            int x = (int) Math.sqrt(i);
            if (x * x == i) list.add(i);
        }
        dataService.submitData(studentCode, qCode, list);
    }
}




Tạo mã ticket - Object
[Mã câu hỏi (qCode): w45g7ADJ].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để quản lý thông tin vé trong hệ thống bán vé sự kiện. Chương trình sẽ ngẫu nhiên tạo ra đối tượng Ticket với các giá trị ban đầu và cung cấp cho RMI client như sau:
    Giao diện từ xa:
public interface ObjectService extends Remote {
    public Serializable requestObject(String studentCode, String qCode) throws RemoteException;
    public void submitObject(String studentCode, String qCode, Serializable object) throws RemoteException;
}
Lớp Ticket gồm các thuộc tính: id String, eventName String, saleDate String, ticketCode String.
•        Trường dữ liệu: private static final long serialVersionUID = 20241133L;
•        02 hàm khởi dựng:
            public Ticket()
            public Ticket(String id, String eventName, String saleDate)
Trong đó:
•        Interface ObjectService và lớp Ticket được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ObjectService được đăng ký với RegistryServer: RMIObjectService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với đối tượng vé được nhận từ RMI Server:
a. Triệu gọi phương thức requestObject để nhận đối tượng Ticket ngẫu nhiên từ server.
b. Tạo mã ticketCode cho vé dựa trên các quy tắc sau:
•        Bắt đầu với hai chữ cái là: Chữ cái đầu tiên và cuối cùng của eventName, viết hoa.
•        Thêm ngày và tháng từ saleDate (theo định dạng "MMdd")
•        Kết thúc bằng hai chữ số là: Chữ số lớn nhất và nhỏ nhất không xuất hiện trong saleDate.
            Ví dụ: tên sự kiện là "Charity Concert", và ngày bán là "15/06/2024", mã ticketCode sẽ là "CT061593".
c. Cập nhật giá trị ticketCode trong đối tượng Ticket.
d. Triệu gọi phương thức submitObject để gửi đối tượng Ticket đã được xử lý trở lại server.
e. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class CapNhatVe {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN380";
        String qCode = "w45g7ADJ";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ObjectService objectService = (ObjectService) registry.lookup("RMIObjectService");
        
        Ticket ticket = (Ticket) objectService.requestObject(studentCode, qCode);
        System.out.println(ticket);
        
        String eventName = ticket.getEventName();
        String saleDate = ticket.getSaleDate();
        StringBuilder code = new StringBuilder();
        
        code.append(eventName.charAt(0));
        code.append(eventName.charAt(eventName.length() - 1));
        code.append(saleDate.substring(3, 5));
        code.append(saleDate.substring(0, 2));
        
        boolean[] used = new boolean[10];
        for (char c : saleDate.toCharArray()) {
            if (Character.isDigit(c)) {
                used[c - '0'] = true;
            }
        }
        int maxDigit = -1;
        int minDigit = 10;
        for (int i = 0; i <= 9; i++) {
            if (!used[i]) {
                maxDigit = Math.max(maxDigit, i);
                minDigit = Math.min(minDigit, i);
            }
        }
       
        code.append(maxDigit).append(minDigit);
        System.out.println(code.toString().toUpperCase());
        ticket.setTicketCode(code.toString().toUpperCase());
        objectService.submitObject(studentCode, qCode, ticket);
    }
}


Tạo mã event - Object
[Mã câu hỏi (qCode): e4FmzUU4].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để quản lý thông tin các sự kiện trong hệ thống tổ chức sự kiện. Chương trình sẽ ngẫu nhiên tạo ra đối tượng Event với các giá trị ban đầu và cung cấp cho RMI client như sau:
    Giao diện từ xa:
public interface ObjectService extends Remote {
    public Serializable requestObject(String studentCode, String qCode) throws RemoteException;
    public void submitObject(String studentCode, String qCode, Serializable object) throws RemoteException;
}
Lớp Event gồm các thuộc tính: id String, eventName String, eventDate String, expectedAttendance int, eventCode String.
•        Trường dữ liệu: private static final long serialVersionUID = 20241131L;
•        02 hàm khởi dựng:
public Event()
           public Event(String id, String eventName, String eventDate, int expectedAttendance)
Trong đó:
•        Interface ObjectService và lớp Event được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ObjectService được đăng ký với RegistryServer: RMIObjectService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với đối tượng sự kiện được nhận từ RMI Server:
a. Triệu gọi phương thức requestObject để nhận đối tượng Event ngẫu nhiên từ server.
b. Tạo mã eventCode cho sự kiện dựa trên các quy tắc sau:
•        Nếu expectedAttendance >= 1000, thêm "L" vào eventCode;     Nếu expectedAttendance từ 500 đến 999, thêm "M" vào eventCode;     Nếu expectedAttendance dưới 500, thêm "S" vào eventCode.
•        Thêm chữ cái đầu và cuối của eventName, tất cả viết hoa.
•        Thêm ngày và tháng từ eventDate (theo định dạng "ddMM").
Ví dụ: Nếu sự kiện có tên là "Charity Run", ngày diễn ra là "2024-05-12" và số lượng người tham gia dự kiến là 1200, mã eventCode sẽ là "LCR1205".
c. Cập nhật giá trị eventCode trong đối tượng Event.
d. Triệu gọi phương thức submitObject để gửi đối tượng Event đã được xử lý trở lại server.
e. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class TaoVeSuKien {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN201";
        String qCode = "e4FmzUU4";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ObjectService objectService = (ObjectService) registry.lookup("RMIObjectService");
        
        Event event = (Event) objectService.requestObject(studentCode, qCode);
        System.out.println(event);
        
        int expectedAttendance = event.getExpectedAttendance();
        String eventCode = "";
        if (expectedAttendance >= 1000) eventCode += "L";
        else if (expectedAttendance >= 500) eventCode += "M";
        else eventCode += "S";
        
        eventCode += event.getEventName().charAt(0);
        eventCode += event.getEventName().charAt(event.getEventName().length() - 1);
        eventCode = eventCode.toUpperCase();
        
        String eventDate = event.getEventDate();
        eventCode += eventDate.substring(8, 10);
        eventCode += eventDate.substring(5,7);
        System.out.println(eventCode);
        
        event.setEventCode(eventCode);
        objectService.submitObject(studentCode, qCode, event);
        
    }
}


Tạo mã book - Object
[Mã câu hỏi (qCode): V6uwEETH].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để gán mã code cho sách trong một hệ thống quản lý thư viện. Chương trình sẽ ngẫu nhiên tạo ra đối tượng Book với các giá trị ban đầu và cung cấp cho RMI client như sau:
Giao diện từ xa:
public interface ObjectService extends Remote {
    public Serializable requestObject(String studentCode, String qCode) throws RemoteException;
    public void submitObject(String studentCode, String qCode, Serializable object) throws RemoteException;
}
Lớp Book gồm các thuộc tính: id String, title String, author String, yearPublished int, pageCount int, code String.
Trường dữ liệu: private static final long serialVersionUID = 20241123L;
02 hàm khởi dựng:
    public Book()
    public Book(String id, String title, String author, int yearPublished, int pageCount)
Trong đó:
    Interface ObjectService và lớp Book được viết trong package RMI.
    Đối tượng cài đặt giao diện từ xa ObjectService được đăng ký với RegistryServer: RMIObjectService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với đối tượng sách được nhận từ RMI Server:
a. Triệu gọi phương thức requestObject để nhận đối tượng Book ngẫu nhiên từ server.
b. Tạo mã code cho sách dựa trên các thành phần sau:
•        Lấy chữ cái đầu của họ và tên đầu của tác giả. Ví dụ, với tác giả "John Doe", hai chữ cái đầu sẽ là "JD".
•        Lấy hai chữ số cuối cùng của năm xuất bản (yearPublished). Ví dụ, nếu yearPublished là 1985, sẽ lấy "85".
•        Lấy tổng số chữ cái trong title của sách.
•        Lấy số chữ số của pageCount (số trang) và nếu số chữ số < 3, thêm các số 0 ở đầu để đạt đủ ba chữ số.
Kết hợp tất cả các thành phần trên để tạo ra mã code theo định dạng: "[Chữ cái đầu tên tác giả][Hai chữ số cuối của năm xuất bản][Tổng số chữ cái trong title][Số chữ số của pageCount]". Ví dụ, nếu tác giả là "Jane Austen", yearPublished là 1813, title là "Pride and Prejudice" với 18 ký tự, và pageCount là 345, thì mã code sẽ là: "JA1318345".
c. Cập nhật giá trị code trong đối tượng Book.
d. Triệu gọi phương thức submitObject để gửi đối tượng Book đã được xử lý trở lại server.
e. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class TaoMaBook {
    public static void main(String[] args) throws RemoteException, NotBoundException {
       String studentCode = "B21DCCN656";
        String qCode = "V6uwEETH";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ObjectService objectService = (ObjectService) registry.lookup("RMIObjectService");
        
        Book book = (Book) objectService.requestObject(studentCode, qCode);
        System.out.println(book);
        String bookCode = "";
        String author = book.getAuthor();
        String[] authors = author.split("\\s+");
        bookCode += authors[0].charAt(0);
        bookCode += authors[authors.length - 1].charAt(0);
        String year = String.valueOf(book.getYearPublished());
        year = year.substring(2, 4);
        bookCode += year;
        
        int totalLetter = book.getTitle().length();
        String pageCount = String.format("%03d", book.getPageCount());
        bookCode += totalLetter + pageCount;
        bookCode = bookCode.toUpperCase();
        System.out.println(bookCode);
        book.setCode(bookCode);
        objectService.submitObject(studentCode, qCode, book);
        
    }
}


Tạo mã BookX - Object
[Mã câu hỏi (qCode): pk2ivjU8].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý mã hóa dữ liệu tác phẩm trong hệ thống quản lý thư viện. Chương trình sẽ ngẫu nhiên tạo ra đối tượng BookX với các giá trị ban đầu và cung cấp cho RMI client như sau:
    Giao diện từ xa:
public interface ObjectService extends Remote {
    public Serializable requestObject(String studentCode, String qCode) throws RemoteException;
    public void submitObject(String studentCode, String qCode, Serializable object) throws RemoteException;
}
Lớp BookX gồm các thuộc tính: id String, title String, author String, yearPublished int, genre String, code String.
Trường dữ liệu: private static final long serialVersionUID = 20241124L;
02 hàm khởi dựng:
    public BookX()
    public BookX(String id, String title, String author, int yearPublished, String genre)
Trong đó:
    Interface ObjectService và lớp BookX được viết trong package RMI.
    Đối tượng cài đặt giao diện từ xa ObjectService được đăng ký với RegistryServer: RMIObjectService.


Yêu cầu:  Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với đối tượng sách được nhận từ RMI Server:
a. Triệu gọi phương thức requestObject để nhận đối tượng BookX ngẫu nhiên từ server.
b. Tạo mã code cho sách dựa trên các quy tắc mã hóa sau:
•        Lấy chữ cái đầu tiên và cuối cùng trong tên tác giả (author). 
•            Lấy hai chữ số cuối cùng của yearPublished.
•            Số lượng chữ cái trong genre của sách.
•            Độ dài của title chia lấy dư cho 10 (ví dụ: với tiêu đề dài 32 ký tự, giá trị này sẽ là 2).
    Kết hợp tất cả các thành phần trên để tạo ra mã code theo định dạng: [Chữ cái đầu và cuối tên tác giả][Hai chữ số cuối của năm xuất bản][Số chữ cái của genre][Độ dài title modulo 10].        Ví dụ, nếu tác giả là "Mark Twain", năm xuất bản là 1884, thể loại là "Fiction" với 7 ký tự, và tiêu đề có 24 ký tự, mã code sẽ là: "MT8474".
c. Cập nhật giá trị code trong đối tượng BookX. 
d. Triệu gọi phương thức submitObject để gửi đối tượng BookX đã được xử lý trở lại server.
e. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class TaoMaBookX {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN360";
        String qCode = "pk2ivjU8";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ObjectService objectService = (ObjectService) registry.lookup("RMIObjectService");
        
        BookX book = (BookX) objectService.requestObject(studentCode, qCode);
        System.out.println(book);
        
        StringBuilder code = new StringBuilder();
        String authorName = book.getAuthor();
        String[] authors = authorName.split("\\s+");
        code.append(authors[0].charAt(0)).append(authors[authors.length - 1].charAt(authors[authors.length - 1].length() - 1));
        
        String year = String.valueOf(book.getYearPublished());
        code.append(year.substring(2,4));
        code.append(book.getGenre().length());
        code.append(book.getTitle().length() % 10);
        book.setCode(code.toString());
        System.out.println(book);
        objectService.submitObject(studentCode, qCode, book);
    }
}




Tạo mã order - Object
[Mã câu hỏi (qCode): ekeVKyX6].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để quản lý thông tin đơn hàng trong hệ thống thương mại điện tử. Chương trình sẽ ngẫu nhiên tạo ra đối tượng Order với các giá trị ban đầu và cung cấp cho RMI client như sau:
    Giao diện từ xa:
public interface ObjectService extends Remote {
    public Serializable requestObject(String studentCode, String qCode) throws RemoteException;
    public void submitObject(String studentCode, String qCode, Serializable object) throws RemoteException;
}
Lớp Order gồm các thuộc tính: id String, customerCode String, orderDate String, shippingType String, orderCode String.
•        Trường dữ liệu: private static final long serialVersionUID = 20241132L;
•        02 hàm khởi dựng:
    public Order()
    public Order(String id, String customerCode, String orderDate, String shippingType)
Trong đó:
•        Interface ObjectService và lớp Order được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa ObjectService được đăng ký với RegistryServer: RMIObjectService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với đối tượng đơn hàng được nhận từ RMI Server:
a. Triệu gọi phương thức requestObject để nhận đối tượng Order ngẫu nhiên từ server.
b. Tạo mã orderCode cho đơn hàng dựa trên các quy tắc sau:
•        Bắt đầu bằng hai ký tự đầu của shippingType, viết in hoa.
•        Kế đến là ba ký tự cuối của customerCode.
•        Cuối cùng là ngày và tháng từ orderDate (theo định dạng "ddMM").
Ví dụ: Nếu đơn hàng có mã khách hàng là "C123456", ngày đặt hàng là "2023-10-05", và loại giao hàng là "Express", thì mã orderCode sẽ là "EX4560510".
c. Cập nhật giá trị orderCode trong đối tượng Order.
d. Triệu gọi phương thức submitObject để gửi đối tượng Order đã được xử lý trở lại server.
e. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;


public class TaoMaOrder {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN116";
        String qCode = "ekeVKyX6";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ObjectService objectService = (ObjectService) registry.lookup("RMIObjectService");
        
        Order order = (Order) objectService.requestObject(studentCode, qCode);
        System.out.println(order);
        
        StringBuilder code = new StringBuilder();
        code.append(order.getShippingType().substring(0,2).toUpperCase());
        String customerCode = order.getCustomerCode();
        code.append(customerCode.substring(customerCode.length() - 3, customerCode.length()));
        String date = order.getOrderDate();
        code.append(date.substring(8, 10)).append(date.substring(5, 7));
        System.out.println(code.toString());
        
        order.setOrderCode(code.toString());
        objectService.submitObject(studentCode, qCode, order);
    }
}




Số nguyên đối xứng - Data
[Mã câu hỏi (qCode): ppefVgSW].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu.
Giao diện từ xa:
public interface DataService extends Remote {
public Object requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, Object data) throws RemoteException;
}
Trong đó:
•        Interface DataService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa DataService được đăng ký với RegistryServer với tên là: RMIDataService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận hai số nguyên dương N và K từ server, đại diện cho khoảng cần kiểm tra (N <= số < K).
b. Xác định tất cả các số nguyên đối xứng (Palindrome Number) trong khoảng từ N đến K. Kết quả trả về là danh sách các số đối xứng thỏa mãn yêu cầu.
Ví dụ: Với N = 50 và K = 150, kết quả là [55, 66, 77, 88, 99, 101, 111, 121, 131, 141].
c. Triệu gọi phương thức submitData để gửi đối tượng List<Integer> danh sách các số nguyên đối xứng đã tìm được trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.ArrayList;
import java.util.List;


public class SoNguyenDoiXung {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN201";
        String qCode = "ppefVgSW";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        DataService dataService = (DataService) registry.lookup("RMIDataService");
        
        Object data = dataService.requestData(studentCode, qCode);
        System.out.println(data);
        String[] parts = data.toString().trim().split(";");
        int n = Integer.parseInt(parts[0]);
        int k = Integer.parseInt(parts[1].trim());
        System.out.println(n);
        System.out.println(k);
        
        List<Integer> list = new ArrayList<>();
        for (int i = n; i < k; i++) {
            if (isPalindrome(i)) {
                list.add(i);
            }
        }
        dataService.submitData(studentCode, qCode, list);
    }


    private static boolean isPalindrome(int number) {
        String s = String.valueOf(number);
        StringBuilder tmp = new StringBuilder(s);
        tmp.reverse();
        
        return s.equals(tmp.toString());
    }
}


Trích xuất chuỗi JSON - Character
[Mã câu hỏi (qCode): 3A799WyM].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý chuỗi.
Giao diện từ xa:
public interface CharacterService extends Remote {
public String requestCharacter(String studentCode, String qCode) throws RemoteException;
public void submitCharacter(String studentCode, String qCode, String strSubmit) throws RemoteException;
}
Trong đó:
•        Interface CharacterService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa CharacterService được đăng ký với RegistryServer với tên là: RMICharacterService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với chuỗi được nhận từ RMI Server:
a. Triệu gọi phương thức requestCharacter để nhận chuỗi JSON ngẫu nhiên từ server với định dạng: "Chuỗi JSON đầu vào".
b. Phân tích cú pháp chuỗi JSON nhận được và trích xuất các cặp key: value dựa trên vị trí của chúng:
•        Các cặp key: value ở vị trí chẵn sẽ được đưa vào chuỗi đầu tiên.
•        Các cặp key: value ở vị trí lẻ sẽ được đưa vào chuỗi thứ hai.
•        Hai chuỗi kết quả sẽ được nối với nhau và phân tách bởi dấu ;
Ví dụ: Chuỗi JSON ban đầu {"name": "Alice", "age": 25, "city": "Wonderland", "country": "Fictionland"} -> Kết quả trích xuất: "name: Alice, city: Wonderland; age: 25, country: Fictionland".
c. Triệu gọi phương thức submitCharacter để gửi chuỗi kết quả trích xuất đã được định dạng trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.ArrayList;
import java.util.List;


public class TrichXuatChuoiJson {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN096";
        String qCode = "3A799WyM";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        CharacterService characterService = (CharacterService) registry.lookup("RMICharacterService");
        
        String jsonString = characterService.requestCharacter(studentCode, qCode);
        System.out.println(jsonString);
        
        String jsonContent = jsonString.trim().substring(1, jsonString.length() - 1);
        String[] pairs = jsonContent.split(",");
        
        List<String> keys = new ArrayList<>();
        List<String> values = new ArrayList<>();
        
        for (String pair : pairs) {
           String[] keyValue = pair.split(":");
           String key = keyValue[0].trim().replace("\"", "");
           String value = keyValue[1].trim().replace("\"", "");
           keys.add(key);
           values.add(value);
        }
        
        StringBuilder evens = new StringBuilder();
        StringBuilder odds = new StringBuilder();
        
        for (int i = 0; i < keys.size(); i++) {
            String keyValuePair = keys.get(i) + ": " + values.get(i);
            if (i % 2 == 0) {
                if (evens.length() > 0) evens.append(", ");
                evens.append(keyValuePair);
            } else {
                if (odds.length() > 0) odds.append(", ");
                odds.append(keyValuePair);
            }
        }
        
        String res = evens.toString() + "; " + odds.toString();
        characterService.submitCharacter(studentCode, qCode, res);
    }
}


Phần tử xuất hiện nhiều nhất trong mảng - Byte
[Mã câu hỏi (qCode): veISbIyt].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server.
b. Tìm phần tử xuất hiện nhiều nhất trong mảng byte[]. Nếu có nhiều phần tử có cùng số lần xuất hiện cao nhất, chỉ cần trả về phần tử đầu tiên xuất hiện trong các phần tử đó.
Ví dụ: Nếu mảng dữ liệu nhận được là [1, 2, 3, 2, 1, 2], phần tử xuất hiện nhiều nhất là 2, với tần suất xuất hiện 3 lần.
c. Triệu gọi phương thức submitData để gửi mảng byte chứa phần tử phổ biến nhất, cùng với tần suất xuất hiện của nó trở lại server.
d. Kết thúc chương trình client


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


public class PhanTuXuatHienNhieuNhat {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN116";
        String qCode = "veISbIyt";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService byteService = (ByteService) registry.lookup("RMIByteService");
        
        byte[] data = byteService.requestData(studentCode, qCode);
        Map<Byte, Integer> map = new HashMap<>();
        for (byte b : data) {
            map.put(b, map.getOrDefault(b, 0) + 1);
        }
        int maxFrequency = Collections.max(map.values());
        System.out.println(maxFrequency);
        
        byte mostByte = 0;
        for (byte b : data) {
            if (map.get(b) == maxFrequency) {
                mostByte = b;
                break;
            }
        }
        byte[] res = new byte[2];
        res[0] = mostByte;
        res[1] = (byte) maxFrequency;
        byteService.submitData(studentCode, qCode, res);
    }
}


Phần tử xuất hiện ít nhất trong mảng - Byte
[Mã câu hỏi (qCode): Xr2zYz9F].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu nhị phân.
Giao diện từ xa:
public interface ByteService extends Remote {
public byte[] requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, byte[] data) throws RemoteException;
}
Trong đó:
•        Interface ByteService được viết trong package RMI.
Đối tượng cài đặt giao diện từ xa ByteService được đăng ký với RegistryServer với tên là: RMIByteService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhị phân nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một mảng dữ liệu nhị phân (byte[]) từ server.
b. Tìm phần tử có số lần xuất hiện ít nhất trong mảng, nếu có nhiều phần tử có cùng số lần xuất hiện ít nhất, chỉ cần trả về phần tử đầu tiên xuất hiện trong các phần tử đó
Ví dụ: Nếu mảng dữ liệu nhận được là [1, 2, 3, 2, 1], chương trình sẽ tìm ra phần tử xuất hiện ít nhất là 3.
c. Triệu gọi phương thức submitData để gửi mảng byte kết quả chứa phẩn tử có số lần xuất hiện ít nhất và số lần xuất hiện trở lại server.
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.HashMap;
import java.util.Map;


public class PhanTuXuatHienItNhat {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN360";
        String qCode = "Xr2zYz9F";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        ByteService byteService = (ByteService) registry.lookup("RMIByteService");
        
        byte[] data = byteService.requestData(studentCode, qCode);
        Map<Byte, Integer> map = new HashMap<>();
        for (byte b : data) {
            map.put(b, map.getOrDefault(b, 0) + 1);
        }
        byte leastFrequent = data[0];
        int minFrequency = map.get(leastFrequent);
        for (Map.Entry<Byte, Integer> entry : map.entrySet()) {
            if (entry.getValue() < minFrequency) {
                minFrequency = entry.getValue();
            }
        }
        
        int frequency = 0;
        for (byte b : data) {
            if (b == leastFrequent) {
                leastFrequent = b;
                frequency = map.get(b);
                break;
            }
        }
        byte[] res = {leastFrequent, (byte) frequency};
        byteService.submitData(studentCode, qCode, res);
    }
}




Phương sai và độ lệch chuẩn - Data
[Mã câu hỏi (qCode): bKCOOMfA].  Một chương trình (tạm gọi là RMI Server) cung cấp giao diện cho phép triệu gọi từ xa để xử lý dữ liệu.
Giao diện từ xa:
public interface DataService extends Remote {
public Object requestData(String studentCode, String qCode) throws RemoteException;
public void submitData(String studentCode, String qCode, Object data) throws RemoteException;
}
Trong đó:
•        Interface DataService được viết trong package RMI.
•        Đối tượng cài đặt giao diện từ xa DataService được đăng ký với RegistryServer với tên là: RMIDataService.
Yêu cầu: Viết chương trình tại máy trạm (RMI client) để thực hiện các công việc sau với dữ liệu nhận được từ RMI Server:
a. Triệu gọi phương thức requestData để nhận một chuỗi chá tập hợp các số thực từ server.
b. Tính toán phương sai (variance) và độ lệch chuẩn (standard deviation) của tập hợp dữ liệu này (làm tròn tới 02 chữ số thập phân)
Ví dụ: Với tập dữ liệu nhận được “2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0”, phương sai là 4.00 và độ lệch chuẩn là 2.00 
c. Triệu gọi phương thức submitData để gửi chuỗi chứa kết quả phương sai và độ lệch chuẩn trở lại server dưới dạng một cặp giá trị “variance : standard deviation”
d. Kết thúc chương trình client.


Code:


package RMI;


/**
 *
 * @author Nauh
 */
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.util.Arrays;
import java.util.OptionalDouble;


public class PhuongSaiDoLechChuan {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        String studentCode = "B21DCCN410";
        String qCode = "bKCOOMfA";
        
        Registry registry = LocateRegistry.getRegistry("203.162.10.109", 1099);
        DataService dataService = (DataService) registry.lookup("RMIDataService");
        
        String s = (String) dataService.requestData(studentCode, qCode);
        System.out.println(s);
        String[] numberStr = s.split(",\\s*");
        double[] numbers = Arrays.stream(numberStr)
                .mapToDouble(Double::parseDouble)
                .toArray();
        
        double mean = Arrays.stream(numbers).average().orElse(0.0);
        double variance = Arrays.stream(numbers)
                .map(x -> Math.pow(x - mean, 2))
                .average()
                .orElse(0.0);
        
        double standardDeviation = Math.sqrt(variance);
        variance = Math.round(variance * 100.0) / 100.0;
        standardDeviation = Math.round(standardDeviation * 100.0) / 100.0;


        System.out.println(variance);
        System.out.println(standardDeviation);
        
        String res = variance + " : " + standardDeviation;
        dataService.submitData(studentCode, qCode, res);
    }
}




WS
Tìm từ độ dài lớn nhất, nhỏ nhất - CharacterService
[Mã câu hỏi (qCode): wJPz7S6K].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestString với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một chuỗi (String) từ server. Chuỗi này có thể chứa các từ và khoảng trắng.
b. Xử lý chuỗi nhận được để tìm từ có độ dài lớn nhất và từ có độ dài nhỏ nhất trong chuỗi. Nếu có nhiều từ có cùng độ dài lớn nhất hoặc nhỏ nhất, chọn từ xuất hiện đầu tiên trong chuỗi.
c. Tạo một chuỗi mới theo định dạng: "[từ lớn nhất]; [từ nhỏ nhất]".
d. Triệu gọi phương thức submitCharacterString(String studentCode, String qCode, String data) để gửi chuỗi kết quả đã xử lý trở lại server.
Ví dụ: Nếu chuỗi nhận được từ phương thức requestCharacter là "this is a sample test", từ có độ dài lớn nhất là "sample" và từ có độ dài nhỏ nhất là "a". Chuỗi kết quả sẽ là "sample; a", và được gửi lại server qua phương thức submitCharacter.
e. Kết thúc chương trình client.


Code:


package WS;


//import vn.medianews.CharacterService;
//import vn.medianews.CharacterService_Service;
import java.util.List;
import vn.medianews.*;


public class TimTuDoDaiLonNhatVaNhoNhat {
    public static void main(String[] args) {
        String studentCode = "B21DCCN404";
        String qCode = "wJPz7S6K";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        String s = port.requestString(studentCode, qCode);
        System.out.println(s);
        
        String[] words = s.split("\\s+");
        String longestWord = "", shortestWord = words[0];
        for(String word : words) {
            if (word.length() > longestWord.length()) {
                longestWord = word;
            }
            if (word.length() < shortestWord.length()) {
                shortestWord = word;
            }
        }
        System.out.println(longestWord);
        System.out.println(shortestWord);
        
        String res = longestWord + "; " + shortestWord;
        port.submitCharacterString(studentCode, qCode, res);
    }
}


Xác định từ có độ dài lớn nhất và từ có độ dài nhỏ nhất trong mảng chuỗi - CharacterService
[Mã câu hỏi (qCode): qp6cu7bi].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestStringArray với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách chuỗi (List<String>) từ server.
b. Xác định từ có độ dài lớn nhất và từ có độ dài nhỏ nhất trong mảng chuỗi. Nếu có nhiều từ có cùng độ dài lớn nhất hoặc nhỏ nhất, chọn từ xuất hiện đầu tiên trong mảng.
c. Tạo một chuỗi mới theo định dạng: "Longest;Shortest".
d. Triệu gọi phương thức submitCharacterString(String studentCode, String qCode, String data) để gửi chuỗi kết quả đã xử lý trở lại server.
Ví dụ: Nếu mảng chuỗi nhận được từ phương thức requestCharacter là ["apple", "banana", "fig", "pineapple"], từ có độ dài lớn nhất là "pineapple" và từ có độ dài nhỏ nhất là "fig". Chuỗi kết quả sẽ là "pineapple;fig", và được gửi lại server qua phương thức submitCharacter.
e. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.List;
import vn.medianews.*;


public class TuLonNhatNhoNhatTrongMangChuoi {
    public static void main(String[] args) {
        String studentCode = "B21DCCN201";
        String qCode = "qp6cu7bi";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        List<String> list = port.requestStringArray(studentCode, qCode);
        System.out.println(list);
        
        String longestWord = "";
        String shortestWord = list.get(0);
        for (String word : list) {
            if (word.length() > longestWord.length()) longestWord = word;
            if (word.length() < shortestWord.length()) shortestWord = word;
        }
        String res = longestWord + ";" + shortestWord;
        port.submitCharacterString(studentCode, qCode, res);
    }
}




Sắp xếp ký tự - CharacterService
[Mã câu hỏi (qCode): sxwWVlTJ].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestCharacter với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách ký tự (List<Integer>) từ server.
b. Sắp xếp danh sách ký tự nhận được theo thứ tự từ điển (alphabetical order).
c. Triệu gọi phương thức submitCharacterCharArray(String studentCode, String qCode, List<Integer> data) để gửi danh sách ký tự đã sắp xếp trở lại server.
Ví dụ: Nếu mảng ký tự nhận được từ phương thức requestCharacter là ['d', 'a', 'c', 'b'], sau khi sắp xếp theo thứ tự từ điển, mảng kết quả sẽ là ['a', 'b', 'c', 'd']. Mảng này sẽ được gửi lại server qua phương thức submitCharacter.
d. Kết thúc chương trình client.


Code:


package WS;


import java.util.Collections;
import java.util.List;
import vn.medianews.CharacterService;
import vn.medianews.CharacterService_Service;


/**
 *
 * @author Nauh
 */
public class SapXepKyTu {
    public static void main(String[] args) {
        String studentCode = "B21DCCN290";
        String qCode = "sxwWVlTJ";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        List<Integer> list = port.requestCharacter(studentCode, qCode);
        System.out.println(list);
        
        Collections.sort(list);
        port.submitCharacterCharArray(studentCode, qCode, list);
    }
}


Sắp xếp tăng dần theo độ dài của từ trong mảng - CharacterService


[Mã câu hỏi (qCode): 2DM72EPJ].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestStringArray với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách chuỗi (List<String>) từ server..
b. Sắp xếp mảng theo độ dài của từ theo thứ tự tăng dần độ dài của từ.
c. Triệu gọi phương thức submitCharacterStringArray(String studentCode, String qCode, List<String> data) để gửi mảng chuỗi đã sắp xếp trở lại server.
Ví dụ: Nếu mảng chuỗi nhận được từ phương thức requestCharacter là ["apple", "banana", "fig", "pineapple"] mảng sắp xếp tăng dần theo độ dài sẽ là ["fig", "apple", "banana", "pineapple"].
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.Collections;
import java.util.List;
import vn.medianews.*;


public class SapXepTangDanTheoDoDai {
    public static void main(String[] args) {
        String studentCode = "B21DCCN689";
        String qCode = "2DM72EPJ";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        List<String> list = port.requestStringArray(studentCode, qCode);
        System.out.println(list);
        
        Collections.sort(list, (o1, o2) -> o1.length() - o2.length());
        port.submitCharacterStringArray(studentCode, qCode, list);
    }
}




Phần tử lớn và nhỏ thứ K - DataService
[Mã câu hỏi (qCode): K1rkXmIf].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getData với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách số nguyên (List<Integer>) từ server. Phần tử đầu tiên của mảng này là giá trị K.
b. Với danh sách số nguyên nhận được, sử dụng giá trị K (phần tử đầu tiên của của danh sách) để xác định phần tử lớn thứ K và nhỏ thứ K trong các phần tử còn lại (loại bỏ phần tử đầu tiên khi tính toán).
c. Triệu gọi phương thức submitDataIntArray(String studentCode, String qCode, List<Integer> data) để gửi mảng kết quả chứa: phần tử lớn thứ K, phần tử nhỏ thứ K đã tìm được trở lại server.
Ví dụ: Nếu mảng số nguyên nhận được từ phương thức getData là [3, 5, 1, 4, 2], giá trị K là 3. Chương trình client sẽ tìm phần tử lớn thứ 3 và nhỏ thứ 3 trong mảng [5, 1, 4, 2], kết quả là mảng [2, 4] và gửi kết quả này trở lại server qua phương thức submitData.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import vn.medianews.*;


public class PhanTuLonVaNhoThuK {
    public static void main(String[] args) {
        String studentCode = "B21DCCN290";
        String qCode = "K1rkXmIf";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        
        List<Integer> list = port.getData(studentCode, qCode);
        System.out.println(list);
        
        int k = list.get(0);
        list = new ArrayList<>(list.subList(1, list.size()));
        Collections.sort(list);
        System.out.println(list);
        
        int kthSmallest = list.get(k - 1);
        int kthLargest = list.get(list.size() - k);
        List<Integer> res = new ArrayList<>();
        res.add(kthLargest);
        res.add(kthSmallest);
        
        port.submitDataIntArray(studentCode, qCode, res);
    }
}




Sắp xếp chẵn lẻ - DataService
[Mã câu hỏi (qCode): 5ayQRIJN].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getData với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách số nguyên (List<Integer>) từ server.
b. Sắp xếp lại mảng số nguyên nhận được sao cho phần tử chẵn và lẻ xen kẽ nhau theo thứ tự xuất hiện. Nếu không thể xen kẽ đều, các phần tử còn lại sẽ nối tiếp ở cuối mảng. Đảm bảo các phần tử chẵn ở vị trí đầu tiên trong mảng sắp xếp.
c. Triệu gọi phương thức submitDataIntArray(String studentCode, String qCode, List<Integer> data) để gửi danh sách số nguyên đã sắp xếp theo thứ tự chẵn-lẻ xen kẽ trở lại server.
Ví dụ: Nếu mảng số nguyên nhận được từ phương thức getData là [1, 2, 3, 4, 5, 6], sau khi sắp xếp xen kẽ chẵn-lẻ, mảng kết quả sẽ là [2, 1, 4, 3, 6, 5]. Mảng này sẽ được gửi lại server qua phương thức submitData.
d. Kết thúc chương trình client.


Code:




package WS;


import java.util.ArrayList;
import java.util.List;
import vn.medianews.DataService;
import vn.medianews.DataService_Service;


/**
 *
 * @author Nauh
 */
public class SapXepChanLe {
    public static void main(String[] args) {
        String studentCode = "B21DCCN404";
        String qCode = "5ayQRIJN";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        
        List<Integer> list = port.getData(studentCode, qCode);
        System.out.println(list);
        
        List<Integer> res = sortedList(list);
        
        port.submitDataIntArray(studentCode, qCode, res);
    }


    private static List<Integer> sortedList(List<Integer> list) {
        List<Integer> evens = new ArrayList<>();
        List<Integer> odds = new ArrayList<>();
        List<Integer> result = new ArrayList<>();
        
        for(int num : list) {
            if (num % 2 == 0) {
                evens.add(num);
            }
            else odds.add(num);
        }
        
        int i = 0, j = 0;
        while (i < evens.size() && j < odds.size()) {
            result.add(evens.get(i++));
            result.add(odds.get(j++));
        }
        
        while (i < evens.size()) {
            result.add(evens.get(i++));
        }
        
        while (j < odds.size()) {
            result.add(odds.get(j++));
        }
        
        return result;
    }
}


Danh sách hóa đơn của khách hàng có tổng giá trị đơn hàng cao nhất - ObjectService
[Mã câu hỏi (qCode): 5YCpJjMM].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestListOrder với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về danh sách đối tượng Order từ server. Mỗi đối tượng Order có các thuộc tính:
•        customerId: kiểu String, đại diện cho mã khách hàng.
•        amount: kiểu float, đại diện cho giá trị của đơn hàng.
•        status: kiểu String, đại diện cho trạng thái của đơn hàng, với các trạng thái có thể là "completed", "pending", hoặc "canceled".
b. Thực hiện lọc và chỉ giữ lại các hóa đơn của khách hàng có tổng giá trị đơn hàng cao nhất
c. Triệu gọi phương thức submitListOrder(String studentCode, String qCode, List<Order> data) để gửi danh sách hóa đơn của khách hàng có tổng giá trị đơn hàng cao nhất.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import vn.medianews.ObjectService;
import vn.medianews.ObjectService_Service;
import vn.medianews.Order;


public class DonHangCaoNhat {
    public static void main(String[] args) {
        String studentCode = "B21DCCN290";
        String qCode = "5YCpJjMM";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        List<Order> list = port.requestListOrder(studentCode, qCode);
        
        Map<String, Float> map = new HashMap<>();
        for (Order o : list) {
            map.put(o.getCustomerId(), map.getOrDefault(o.getCustomerId(), 0.0f) + o.getAmount());
        }
        
        float maxAmount = Collections.max(map.values());
        System.out.println(maxAmount);
        
        List<Order> res = new ArrayList<>();
        String maxCustomerId = "";
        for (Map.Entry<String, Float> entry : map.entrySet()) {
            if (maxAmount == entry.getValue()) {
                maxCustomerId = entry.getKey();
                break;
            }
        }
        System.out.println(maxCustomerId);
        
        for (Order o : list) {
            if (o.getCustomerId().equals(maxCustomerId)) {
                res.add(o);
            }
        }
        
        port.submitListOrder(studentCode, qCode, res);
    }
}


Lọc ra các đơn hàng có trạng thái là "pending" hoặc "processing" và có ngày đặt hàng (orderDate) quá 30 ngày so với ngày hiện tại - ObjectService
[Mã câu hỏi (qCode): PDZUpY8U].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestListOrderY với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về danh sách đối tượng OrderY từ server. Mỗi đối tượng Order có các thuộc tính:
•        orderId: kiểu String, đại diện cho mã đơn hàng.
•        orderDate: kiểu Date, đại diện cho ngày đặt hàng.
•        status: kiểu String, đại diện cho trạng thái đơn hàng, với các trạng thái có thể là "pending", "processing", hoặc "completed".
•        customerId: kiểu String, đại diện cho mã khách hàng.
b. Lọc ra các đơn hàng có trạng thái là "pending" hoặc "processing" và có ngày đặt hàng (orderDate) quá 30 ngày so với ngày hiện tại -> để tạo danh sách các đơn hàng cần được ưu tiên xử lý.
c. Triệu gọi phương thức submitListOrderY(String studentCode, String qCode, List<OrderY> orderYs) để gửi danh sách đơn hàng đã được lọc trở lại server. 
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import javax.xml.datatype.XMLGregorianCalendar;
import vn.medianews.*;


public class LocDonHang {
    public static void main(String[] args) {
        String studentCode = "B21DCCN201";
        String qCode = "PDZUpY8U";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        List<OrderY> list = port.requestListOrderY(studentCode, qCode);
        System.out.println(list);
        
        List<OrderY> res = filterOrder(list);
        port.submitListOrderY(studentCode, qCode, res);
    
    }


    private static List<OrderY> filterOrder(List<OrderY> list) {
        List<OrderY> res = new ArrayList<>();
        for (OrderY o : list) {
            String status = o.getStatus();
            if (status.equals("pending") || status.equals("processing")) {
                Date currentDate = new Date();
                XMLGregorianCalendar orderDate = o.getOrderDate();
                long time = currentDate.getTime() - orderDate.toGregorianCalendar().getTimeInMillis();
                long days = time / (1000 * 24 * 60 * 60);
                if (days > 30) res.add(o);
            }
        }
        return res;
    }
}




Sắp xếp nhân viên theo ngày bắt đầu - ObjectService
[Mã câu hỏi (qCode): AawwI2F9].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestListEmployeeY với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách đối tượng EmployeeY từ server. Mỗi đối tượng EmployeeY có các thuộc tính:
•        name: kiểu String, đại diện cho tên của nhân viên.
•        startDate: kiểu Date, đại diện cho ngày bắt đầu làm việc của nhân viên.
b. Sắp xếp danh sách EmployeeY theo thứ tự thâm niên từ cao đến thấp (người có ngày bắt đầu làm việc sớm nhất sẽ đứng đầu danh sách).
    Nếu hai nhân viên có cùng ngày bắt đầu làm việc, giữ nguyên thứ tự ban đầu của họ trong danh sách.
c. Triệu gọi phương thức submitListEmployeeY(String studentCode, String qCode, List<EmployeeY> data) để gửi danh sách nhân viên đã sắp xếp trở lại server.
d. Kết thúc chương trình client.


Code:


package WS;


import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import vn.medianews.*;


public class SapXepNhanVien {
    public static void main(String[] args) {
        String studentCode = "B21DCCN404";
        String qCode = "AawwI2F9";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        List<EmployeeY> list = port.requestListEmployeeY(studentCode, qCode);  
       
        for (EmployeeY i : list) {
            System.out.println(i.getName() + " " + i.getStartDate());
        }
        System.out.println();
        
        Collections.sort(list, new Comparator<EmployeeY>() {
            @Override
            public int compare(EmployeeY o1, EmployeeY o2) {
                return o1.getStartDate().compare(o2.getStartDate());
            }
        });
        
        for (EmployeeY i : list) {
            System.out.println(i.getName() + " " + i.getStartDate());
        }
        
        port.submitListEmployeeY(studentCode, qCode, list);
    }
}


Phân tích thừa số nguyên tố - DataService
[Mã câu hỏi (qCode): 1NAQ64aM].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getData với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách số nguyên (List<Integer>) từ server.
b. Thực hiện phân tích mỗi số nguyên nhận được trong danh sách thành các thừa số nguyên tố của nó và lưu các thừa số này vào một chuỗi kết quả.
c. Triệu gọi phương thức submitDataStringArray(String studentCode, String qCode, List<String> data) để gửi danh sách chuỗi các thừa số nguyên tố đã tính được trở lại server.
Ví dụ: Nếu số nguyên trong danh sách là 28 -> sẽ phân tích thành các thừa số nguyên tố "2, 2, 7". Chương trình client thực hiện với từng số nguyên trong danh sách và và gửi danh sách chuỗi kết quả cho từng số này trở lại server qua phương thức submitDataStringArray.
d. Kết thúc chương trình client.


Code:


package WS;


import java.util.ArrayList;
import java.util.List;
import vn.medianews.*;
/**
 *
 * @author Nauh
 */


public class PhanTichThuaSoNguyenTo {
    public static void main(String[] args) {
        String studentCode = "B21DCCN800";
        String qCode = "1NAQ64aM";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        
        List<Integer> list = port.getData(studentCode, qCode);
        System.out.println(list);
        
        List<String> res = new ArrayList<>();
        for(int number : list) {
            String tmp = phanTich(number);
            System.out.println(tmp);
            res.add(tmp);
        }
        
        port.submitDataStringArray(studentCode, qCode, res);
    }


    private static String phanTich(int number) {
        StringBuilder s = new StringBuilder();
        for(int i = 2; i <= Math.sqrt(number); i++) {
            while (number % i == 0) {
                s.append(i).append(", ");
                number /= i;
            }
        }
        if (number > 1) s.append(number);
        String result = s.toString();
        if (result.endsWith(", ")) result = result.substring(0, s.length() - 2);
        return result;
    }
}


Loại bỏ các phần tử trùng lặp, giữ lại lần xuất hiện đầu tiên - DataService
[Mã câu hỏi (qCode): yNEpS3rJ].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getData với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách số nguyên (List<Integer>) từ server.
b. Với danh sách số nguyên nhận được, xóa tất cả các phần tử trùng lặp, giữ lại lần xuất hiện đầu tiên của mỗi phần tử. Mảng kết quả sẽ chỉ chứa các phần tử duy nhất theo thứ tự xuất hiện ban đầu.
c. Triệu gọi phương thức submitDataIntArray(String studentCode, String qCode, List<Integer> data) để gửi mảng kết quả đã loại bỏ các phần tử trùng lặp trở lại server.
Ví dụ: Nếu mảng số nguyên nhận được từ phương thức getData là [1, 2, 2, 3, 4, 3, 5], mảng kết quả sau khi loại bỏ phần tử trùng lặp là [1, 2, 3, 4, 5]. Mảng này sẽ được gửi lại server qua phương thức submitDataIntArray.
d. Kết thúc chương trình client.


Code:


package WS;


import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import vn.medianews.DataService;
import vn.medianews.DataService_Service;


/**
 *
 * @author Nauh
 */
public class LoaiBoKyTuTrung {
    public static void main(String[] args) {
        String studentCode = "B21DCCN680";
        String qCode = "yNEpS3rJ";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        
        List<Integer> list = port.getData(studentCode, qCode);
        System.out.println(list);
        
        Set<Integer> set = new HashSet<>();
        List<Integer> res = new ArrayList<>();
        
        for (int i : list) {
            if (set.add(i)) {
                res.add(i);
            }
        }
        port.submitDataIntArray(studentCode, qCode, res);
    }
}


Sắp xếp theo số lượng nguyên âm tăng dần - CharacterService
[Mã câu hỏi (qCode): SWjHexQG].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestStringArray với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách chuỗi (List<String>) từ server.
b. Sắp xếp các chuỗi trong danh sách theo số lượng nguyên âm tăng dần. Nếu hai chuỗi có cùng số lượng nguyên âm, giữ nguyên thứ tự xuất hiện ban đầu của chúng trong mảng.
c. Triệu gọi phương thức submitCharacterStringArray(String studentCode, String qCode, List<String> data) để gửi danh sách chuỗi đã sắp xếp trở lại server.
Ví dụ: Nếu mảng chuỗi nhận được từ phương thức requestCharacter là ["apple", "kiwi", "banana", "pear"], số lượng nguyên âm trong các từ là:
•        "apple" có 2 nguyên âm
•        "kiwi" có 2 nguyên âm
•        "pear" có 2 nguyên âm
•        "banana" có 3 nguyên âm
Sau khi sắp xếp theo số lượng nguyên âm tăng dần, kết quả sẽ là ["apple", "kiwi", "pear", , "banana"]. Danh sách này sẽ được gửi lại server qua phương thức submitCharacter.
d. Kết thúc chương trình client.


Code:


package WS;


import java.util.Collections;
import java.util.List;
import vn.medianews.CharacterService;
import vn.medianews.CharacterService_Service;


/**
 *
 * @author Nauh
 */
public class SapXepTheoSoLuongNguyenAm {
    public static void main(String[] args) {
        String studentCode = "B21DCCN680";
        String qCode = "SWjHexQG";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        List<String> list = port.requestStringArray(studentCode, qCode);
        System.out.println(list);
        
        Collections.sort(list, (o1, o2) -> {
            return countVowels(o1) - countVowels(o2);
        });
        System.out.println(list);
        
        port.submitCharacterStringArray(studentCode, qCode, list);
    }
    
    public static int countVowels(String s) {
        int cnt = 0;
        String vowels = "ueoaiUEOAI";
        for (char c : s.toCharArray()) {
            if (vowels.indexOf(c) != -1) cnt++;
        }
        return cnt;
    }
}


Lọc các sinh viên có điểm thuộc nhóm A, D - ObjectService
[Mã câu hỏi (qCode): raTXLlOF].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestListStudent với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách đối tượng Student từ server. Mỗi đối tượng Student có các thuộc tính:
•        name: kiểu String, đại diện cho tên của sinh viên.
•        score: kiểu float, đại diện cho điểm trung bình của sinh viên.
b. Thực hiện lọc và giữ lại các sinh viên có điểm thuộc nhóm A, D. Biết rằng điểm các mức sau:  A: điểm từ 8.0 trở lên; B: điểm từ 6.5 đến dưới 8.0; C: điểm từ 5.0 đến dưới 6.5; D: điểm dưới 5.0
c. Triệu gọi phương thức submitListStudent(String studentCode, String qCode, List<Student> students) để gửi danh sách sinh viên thuộc nhóm A và D. 
d. Kết thúc chương trình client.


Code:


package WS;


import java.util.ArrayList;
import java.util.List;
import vn.medianews.ObjectService;
import vn.medianews.ObjectService_Service;
import vn.medianews.Student;


/**
 *
 * @author Nauh
 */
public class LocSinhVien {
    public static void main(String[] args) {
        String studentCode = "B21DCCN680";
        String qCode = "raTXLlOF";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        List<Student> list = port.requestListStudent(studentCode, qCode);
        System.out.println(list);
        
        List<Student> res = new ArrayList<>();
        for (Student student : list) {
            if (student.getScore() >= 8 || student.getScore() < 5) res.add(student);
        }
        port.submitListStudent(studentCode, qCode, res);
    }
}


Lọc sinh viên có điểm số cao nhất theo từng môn học - ObjectService
[Mã câu hỏi (qCode): tLUO8Gs4].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestListStudentY với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về danh sách đối tượng StudentY từ server. Mỗi đối tượng Student có các thuộc tính:
•        studentId: kiểu String, đại diện cho mã sinh viên.
•        name: kiểu String, đại diện cho tên sinh viên.
•        subject: kiểu String, đại diện cho tên môn học.
•        score: kiểu float, đại diện cho điểm số của sinh viên trong môn học.
b. Thực hiện: Lọc và giữ lại sinh viên có điểm số cao nhất theo từng môn học
c. Triệu gọi phương thức submitListStudentY(String studentCode, String qCode, List<StudentY> studentYs) để gửi danh sách sinh viên đạt điểm cao nhất theo từng môn học trở lại server (Lưu ý bảo toàn vị trí xuất hiện của sinh viên trong danh sách ban đầu)
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import vn.medianews.*;


public class LocSinhVienCoDiemCaoNha {
    public static void main(String[] args) {
         String studentCode = "B21DCCN626";
        String qCode = "tLUO8Gs4";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        List<StudentY> list = port.requestListStudentY(studentCode, qCode);
        Map<String, StudentY> topScoreMap = new LinkedHashMap<>();
        List<StudentY> topStudents = new ArrayList<>();
        
        for (StudentY student : list) {
            String subject = student.getSubject();
            if (!topScoreMap.containsKey(subject) || student.getScore() > topScoreMap.get(subject).getScore()) {
                topScoreMap.put(subject, student);
            }
        }
        
        for (Map.Entry<String, StudentY> entry : topScoreMap.entrySet()) {
            topStudents.add(entry.getValue());
        }
        
        port.submitListStudentY(studentCode, qCode, topStudents);
    }
}




Tính số ngày làm việc - ObjectService
[Mã câu hỏi (qCode): LG2Tp7wW].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestEmployee với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một đối tượng Employee từ server. Đối tượng này có các thuộc tính:
•        startDate: kiểu Date, đại diện cho ngày bắt đầu công việc của nhân viên.
•        endDate: kiểu Date, đại diện cho ngày kết thúc công việc của nhân viên.
b. Tính toán số ngày làm việc (workingDays) giữa startDate và endDate, loại trừ các ngày cuối tuần (thứ Bảy và Chủ Nhật). Cập nhật thuộc tính workingDays trong đối tượng Employee với giá trị đã tính toán.
c. Triệu gọi phương thức submitEmployee(String studentCode, String qCode, Employee object) để gửi đối tượng Employee với số ngày làm việc đã được tính toán trở lại server.
Ví dụ: Nếu đối tượng Employee có startDate là 01-09-2023 (thứ Sáu) và endDate là 07-09-2023 (thứ Năm), số ngày làm việc sẽ tính từ ngày 01-09 đến 07-09, loại trừ ngày cuối tuần, kết quả là 5 ngày làm việc. 
Đối tượng Employee với giá trị workingDays = 5 sẽ được gửi lại server qua phương thức submitEmployee.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.Calendar;
import java.util.GregorianCalendar;
import javax.xml.datatype.XMLGregorianCalendar;
import vn.medianews.*;


public class TinhSoNgayLamViec {
    public static void main(String[] args) {
        String studentCode = "B21DCCN800";
        String qCode = "LG2Tp7wW";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        Employee employee = port.requestEmployee(studentCode, qCode);
        System.out.println(employee.getStartDate());
        System.out.println(employee.getEndDate());
        
        int workingDays = calculateWorkingDays(employee.getStartDate(), employee.getEndDate());
        employee.setWorkingDays(workingDays);
        
        port.submitEmployee(studentCode, qCode, employee);
        
    }


    private static int calculateWorkingDays(XMLGregorianCalendar startDate, XMLGregorianCalendar endDate) {
        Calendar start = new GregorianCalendar();
        Calendar end = new GregorianCalendar();
        start.setTime(startDate.toGregorianCalendar().getTime());
        end.setTime(endDate.toGregorianCalendar().getTime());
        
        int workingDays = 0;
        
        while (!start.after(end)) {
            int dayOfWeek = start.get(Calendar.DAY_OF_WEEK);
            if (dayOfWeek != Calendar.SATURDAY && dayOfWeek != Calendar.SUNDAY) {
                workingDays++;
            }
            start.add(Calendar.DATE, 1);
        }
        return workingDays;
    }
}


Lọc khách hàng mua nhiều - ObjectService
[Mã câu hỏi (qCode): pdmJLhhq].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestListCustomer với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về danh sách đối tượng Customer từ server. Mỗi đối tượng Customer có các thuộc tính:
•        customerId: kiểu String, đại diện cho mã khách hàng.
•        location: kiểu String, đại diện cho địa điểm của khách hàng.
•        purchaseCount: kiểu int, đại diện cho số lần mua hàng của khách hàng.
•        totalSpent: kiểu float, đại diện cho tổng số tiền đã chi tiêu của khách hàng.
b. Lọc và giữ lại các khách hàng có totalSpent lớn hơn 5000 và có purchaseCount từ 5 trở lên.
c. Triệu gọi phương thức submitListCustomer(String studentCode, String qCode, List<Customer> customers) để gửi danh sách các khách hàng tiềm năng trở lại server. 
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.List;
import vn.medianews.*;


public class LocKhachHangMuaNhieu {
    public static void main(String[] args) {
        String studentCode = "B21DCCN689";
        String qCode = "pdmJLhhq";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        List<Customer> list = port.requestListCustomer(studentCode, qCode);
        List<Customer> res = new ArrayList<>();
        for (Customer c : list) {
            if (c.getTotalSpent() > 5000 && c.getPurchaseCount() >= 5) res.add(c);
        }
        
        port.submitListCustomer(studentCode, qCode, res);
    }
}






Lọc khách hàng chưa có giao dịch trong vòng 6 tháng - ObjectService
[Mã câu hỏi (qCode): 88ZWBCBV].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestListCustomerY với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về danh sách đối tượng CustomerY từ server. Mỗi đối tượng CustomerY có các thuộc tính:
    customerId: kiểu String, đại diện cho mã khách hàng.
    lastTransactionDate: kiểu Date, đại diện cho ngày giao dịch gần nhất của khách hàng.
b. Lọc và giữ lại các khách hàng chưa có giao dịch nào trong vòng 6 tháng qua (so với ngày hiện tại).
c. Triệu gọi phương thức submitListCustomerY(String studentCode, String qCode, List<CustomerY> customerYs) để gửi danh sách các khách hàng không hoạt động trong 6 tháng trở lại server. 
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import javax.xml.datatype.XMLGregorianCalendar;
import vn.medianews.*;


public class LocKhachHangChuaGiaoDich {
    public static void main(String[] args) {
        String studentCode = "B21DCCN344";
        String qCode = "88ZWBCBV";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        List<CustomerY> list = port.requestListCustomerY(studentCode, qCode);
        list.forEach(System.out::println);
        
        List<CustomerY> res = new ArrayList<>();
        Date currentDate = new Date();
        for (CustomerY cus : list) {
            if (isIntransaction(cus.getLastTransactionDate(), currentDate)) {
                res.add(cus);
            }
        }
        
        port.submitListCustomerY(studentCode, qCode, res);
    }
    
    private static boolean isIntransaction(XMLGregorianCalendar lastTransactionDate, Date currentDate) {
        Calendar sixMonthsAgo = Calendar.getInstance();
        sixMonthsAgo.setTime(currentDate);
        sixMonthsAgo.add(Calendar.MONTH, -6);
        
        return lastTransactionDate.toGregorianCalendar().getTime().before(sixMonthsAgo.getTime());
    }
}


Chuyển sang cơ số 8 và 16 - DataService
[Mã câu hỏi (qCode): U7z6LuPt].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getData với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách số nguyên (List<Integer>) từ server.
b. Chuyển đổi số nguyên nhận được từ hệ thập phân sang cả hệ cơ số 8 (bát phân) và hệ cơ số 16 (thập lục phân). Biểu diễn kết quả dưới dạng chuỗi cho mỗi hệ cơ số.
c. Triệu gọi phương thức submitDataStringArray(String studentCode, String qCode, List<String> data) để gửi danh sách chuỗi kết quả. Trong đó: Mỗi phần tử là chuỗi kết hợp giữa kết quả chuyển đổi sang hệ cơ số 8 và chuỗi kết quả chuyển đổi sang hệ cơ số 16.
Ví dụ: Nếu số nguyên nhận64 thì:
    Chuyển đổi sang hệ cơ số 8, tạo thành chuỗi "100".
    Chuyển đổi sang hệ cơ số 16, tạo thành chuỗi "40".
-> Chuỗi kết quả tương ứng sẽ là "100|40". Chương trình client thực hiện lần lượt và gửi danh sách chuỗi này trở lại server qua phương thức submitDataStringArray.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.List;
import vn.medianews.*;


public class CoSo8Va16 {
    public static void main(String[] args) {
        String studentCode = "B21DCCN032";
        String qCode = "U7z6LuPt";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        
        List<Integer> list = port.getData(studentCode, qCode);
        System.out.println(list);
        
        List<String> res = new ArrayList<>();
        for (int i : list) {
            String octal = Integer.toOctalString(i);
            String hex = Integer.toHexString(i).toUpperCase();
            String resString = octal + "|" + hex;
            res.add(resString);
        }
        System.out.println(res);
        port.submitDataStringArray(studentCode, qCode, res);
    }
}


Đếm số lần xuất hiện của từng phần tử trong mảng - DataService
[Mã câu hỏi (qCode): j1AhbOxw].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getData với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách số nguyên (List<Integer>) từ server.
b. Với mảng số nguyên nhận được, thực hiện đếm số lần xuất hiện của từng phần tử trong mảng và lưu kết quả vào một chuỗi theo định dạng: giá trị của phần tử, số lần xuất hiện tương ứng của nó.
c. Triệu gọi phương thức submitDataStringArray(String studentCode, String qCode, List<String> data) để gửi danh sách chuỗi kết quả chứa cặp giá trị [phần tử, tần suất] của từng phần tử đã tính được trở lại server. (chú ý là sắp xếp theo giá trị phần tử tăng dần)
Ví dụ: Nếu mảng số nguyên nhận được từ phương thức getData là [1, 2, 2, 3, 3, 3], kết quả tần suất sẽ là ["1, 1", "2, 2", "3, 3"], và danh sách kết quả này sẽ được gửi lại server qua phương thức submitDataStringArray.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import vn.medianews.*;


public class TanSuatXuatHien {
    public static void main(String[] args) {
        String studentCode = "B21DCCN269";
        String qCode = "j1AhbOxw";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        
        List<Integer> list = port.getData(studentCode, qCode);
        System.out.println(list);
        
        Map<Integer, Integer> map = new LinkedHashMap<>();
        for (int num : list) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        List<String> res = new ArrayList<>();
        map.entrySet()
                    .stream()
                    .sorted(Map.Entry.comparingByKey()) // Sắp xếp theo key tăng dần
                    .forEach(entry -> res.add(entry.getKey() + ", " + entry.getValue()));
        
        System.out.println(res);
        port.submitDataStringArray(studentCode, qCode, res);
    }
}


Phân loại các nhóm nguyên âm - CharacterService
[Mã câu hỏi (qCode): fc1HSJjO].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestStringArray với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách chuỗi (List<String>) từ server.
b. Phân loại các từ trong mảng chuỗi thành các nhóm có cùng số lượng nguyên âm. Tạo một chuỗi cho mỗi nhóm, trong đó liệt kê các từ cách nhau bằng dấu phẩy, và sắp xếp các từ theo thứ tự từ điển trong mỗi nhóm.
c. Triệu gọi phương thức submitCharacterStringArray(String studentCode, String qCode, List<String> data) để gửi danh sách chuỗi kết quả trở lại server, trong đó mỗi phần tử là một nhóm từ với cùng số lượng nguyên âm.
Ví dụ: Nếu danh sách chuỗi nhận được từ phương thức requestCharacter là ["apple", "banana", "pear", "grape", "kiwi"], các nhóm có thể là:
•        Nhóm 2 nguyên âm: "apple, banana"
•        Nhóm 1 nguyên âm: "grape, kiwi, pear"
Danh sách kết quả sẽ là ["apple, banana", "grape, kiwi, pear"], và danh sách này sẽ được gửi lại server qua phương thức submitCharacter.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import vn.medianews.CharacterService;
import vn.medianews.CharacterService_Service;


public class PhanLoaiNguyenAm {
    public static void main(String[] args) {
        String studentCode =  "B21DCCN269";
        String qCode = "fc1HSJjO";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        List<String> list = port.requestStringArray(studentCode, qCode);
        System.out.println(list);
        
        Map<Integer, List<String>> group = new HashMap<>();
        for (String word : list) {
            int vowelCount = countVowels(word);
            group.computeIfAbsent(vowelCount, k -> new ArrayList<>()).add(word);
        }
        
        for (Map.Entry<Integer, List<String>> entry : group.entrySet()) {
            Collections.sort(entry.getValue());
        }
        List<String> res = new ArrayList<>();
        for (Map.Entry<Integer, List<String>> entry : group.entrySet()) {
            String tmp = String.join(", ", entry.getValue());
            res.add(tmp);
        }
        
        port.submitCharacterStringArray(studentCode, qCode, res);
    }
    public static int countVowels(String word) {
        int cnt = 0;
        for (char c : word.toLowerCase().toCharArray()) {
            if ("ueoai".indexOf(c) != -1) cnt++;
        }
        return cnt;
    }
}


Loại bỏ ký tự đặc biệt, số - CharacterService
[Mã câu hỏi (qCode): sS7uimwi].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestString với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một chuỗi (String) từ server. Chuỗi có thể chứa các ký tự đặc biệt và khoảng trắng.
b. Tạo một chuỗi mới từ chuỗi nhận được bằng cách:
•        Loại bỏ tất cả các ký tự đặc biệt, số, chỉ các ký tự chữ cái.
•        Đảo ngược chuỗi kết quả sau khi đã loại bỏ các ký tự đặc biệt.
c. Triệu gọi phương thức submitCharacterString(String studentCode, String qCode, String cleanedAndReversedString) để gửi chuỗi đã được làm sạch và đảo ngược trở lại server.
Ví dụ: Nếu chuỗi nhận được từ phương thức requestString là "hello@ world! 2024", sau khi loại bỏ các ký tự đặc biệt sẽ thành "helloworld", và khi đảo ngược sẽ là "dlrowolleh". Chuỗi kết quả "dlrowolleh" sẽ được gửi lại server qua phương thức submitCharacterString.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import vn.medianews.*;


public class LoaiBoKyTuDacBiet {
    public static void main(String[] args) {
        String studentCode = "B21DCCN380";
        String qCode = "sS7uimwi";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        String s = port.requestString(studentCode, qCode);
        System.out.println(s);
        
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isAlphabetic(c)) sb.append(c);
        }
        sb.reverse();
        port.submitCharacterString(studentCode, qCode, sb.toString());
    }
}


Tính toán giá sản phẩm - ObjectService 
[Mã câu hỏi (qCode): WoBQK2cv].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestProductY với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một đối tượng ProductY từ server. Đối tượng này có các thuộc tính:
•        price (giá gốc): float, đại diện cho giá của sản phẩm.
•        taxRate (thuế): float, đại diện cho phần trăm thuế áp dụng trên giá gốc.
•        discount (chiết khấu): float, đại diện cho phần trăm chiết khấu áp dụng trên giá gốc.
b. Thực hiện 
•        Tính toán giá cuối cùng của sản phẩm (finalPrice) theo công thức:
                        finalPrice = price * (1 + taxRate / 100) * (1 - discount / 100)
•        Cập nhật thuộc tính finalPrice trong đối tượng ProductY với giá trị đã tính toán.
c. Triệu gọi phương thức submitProductY(String studentCode, String qCode, ProductY object) để gửi đối tượng ProductY với giá cuối cùng đã được tính toán trở lại server.
Ví dụ: Nếu đối tượng ProductY có các thuộc tính price = 100.0, taxRate = 10.0, và discount = 5.0, thì finalPrice sẽ được tính là:
                    finalPrice = 100 * (1 + 10/100) * (1 - 5/100) = 104.5
Đối tượng ProductY với giá trị finalPrice = 104.5 sẽ được gửi lại server qua phương thức submitProductY.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import vn.medianews.*;


public class TinhToanGiaSanPham {
    public static void main(String[] args) {
        String studentCode = "B21DCCN703";
        String qCode = "WoBQK2cv";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        ProductY productY = port.requestProductY(studentCode, qCode);
        System.out.println(productY);
        
        float finalPrice = productY.getPrice() * (1 + productY.getTaxRate() / 100) * (1 - productY.getDiscount() / 100);
        productY.setFinalPrice(finalPrice);
        
        port.submitProductY(studentCode, qCode, productY);
    }
}


Xoay vòng ký tự theo chiều phải - CharacterService
[Mã câu hỏi (qCode): MzROc3MW].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestCharacter với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách ký tự (List<Integer>) từ server.
b. Thực hiện xoay vòng các ký tự trong danh sách theo chiều phải, số lần xoay vòng bằng đúng giá trị nguyên trong bảng mã ASCII của ký tự đầu tiên.
c. Triệu gọi phương thức submitCharacterCharArray(String studentCode, String qCode, List<Integer> data) để gửi mảng ký tự đã xoay vòng trở lại server.
Ví dụ: Nếu mảng ký tự nhận được từ phương thức requestCharacter là ['a', 'b', 'c', 'd'], giá trị nguyên của ký tự 'a' trong bảng mã ASCII là 97, thực hiện xoay vòng phải 97 lần sẽ trả lại mảng ['d', 'a', 'b', 'c']. Mảng này sẽ được gửi lại server qua phương thức submitCharacterCharArray.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.Collections;
import java.util.List;
import vn.medianews.*;


public class XoayVongKyTu {
    public static void main(String[] args) {
        String studentCode = "B21DCCN626";
        String qCode = "MzROc3MW";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        List<Integer> list = port.requestCharacter(studentCode, qCode);
        System.out.println(list);
        
        int rotateTimes = list.get(0);
        Collections.rotate(list, rotateTimes);
        port.submitCharacterCharArray(studentCode, qCode, list);
    }
}


Thập phân -> Nhị phân - DataService
[Mã câu hỏi (qCode): XfNnjG5b].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getData với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách số nguyên (List<Integer>) từ server.
b. Chuyển đổi số nguyên nhận được từ hệ thập phân sang hệ nhị phân và biểu diễn kết quả dưới dạng chuỗi nhị phân.
c. Triệu gọi phương thức submitDataStringArray(String studentCode, String qCode, List<String> data) để gửi chuỗi nhị phân đã chuyển đổi trở lại server.
Ví dụ: Nếu mỗi số nguyên nhận được từ phương thức getData, chương trình client sẽ chuyển đổi sang chuỗi nhị phân là "1010", và gửi mảng chuỗi này trở lại server qua phương thức submitData.
d. Kết thúc chương trình client.


Code:
package WS;
/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.List;
import vn.medianews.*;


public class ThapPhanSangNhiPhan {
    public static void main(String[] args) {
        String studentCode = "B21DCCN263";
        String qCode = "XfNnjG5b";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        
        List<Integer> list = port.getData(studentCode, qCode);
        System.out.println(list);
        
        List<String> res = new ArrayList<>();
        for (int i : list) {
            String tmp = Integer.toBinaryString(i);
            res.add(tmp);
        }
        port.submitDataStringArray(studentCode, qCode, res);
    }
}


Lọc các dự án gần hoàn thành - ObjectService
[Mã câu hỏi (qCode): xXTlLpob].  Một dịch vụ web được định nghĩa và mô tả trong tệp ObjectService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/ObjectService?wsdl để xử lý các bài toán với đối tượng.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với ObjectService thực hiện các công việc sau:
a. Triệu gọi phương thức requestListProject với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về danh sách đối tượng Project từ server. Mỗi đối tượng Project có các thuộc tính:
•        projectId: kiểu String, đại diện cho mã dự án.
•        projectName: kiểu String, đại diện cho tên dự án.
•        completionPercentage: kiểu float, đại diện cho tỷ lệ hoàn thành của dự án (tính theo %).
•        dueDate: kiểu Date, đại diện cho hạn hoàn thành của dự án.
b. Lọc và giữ lại các dự án có completionPercentage từ 80% trở lên và có hạn hoàn thành (dueDate) trong vòng 15 ngày tới (tính từ ngày hiện tại).
c. Triệu gọi phương thức submitListProject(String studentCode, String qCode, List<Project> projects) để gửi danh sách các dự án gần hoàn thành và cần ưu tiên trở lại server. 
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.TimeUnit;
import javax.xml.datatype.XMLGregorianCalendar;
import vn.medianews.*;


public class LocDuAnGanHoanThanh {
    public static void main(String[] args) {
        String studentCode = "B21DCCN116";
        String qCode = "xXTlLpob";
        
        ObjectService_Service service = new ObjectService_Service();
        ObjectService port = service.getObjectServicePort();
        
        List<Project> list = port.requestListProject(studentCode, qCode);
        List<Project> res = new ArrayList<>();
        Date currentDate = new Date();
        for (Project p : list) {
            if (p.getCompletionPercentage() >= 80 && isWithinDays(currentDate, p.getDueDate())) {
                res.add(p);
            }
        }
        port.submitListProject(studentCode, qCode, res);
    }


    private static boolean isWithinDays(Date currentDate, XMLGregorianCalendar dueDate) {
        long time = dueDate.toGregorianCalendar().getTimeInMillis() - currentDate.getTime();
        long days = TimeUnit.MILLISECONDS.toDays(time);
        return days >= 0 && days <= 15;
    }
}


Tạo số lớn nhất - DataService
[Mã câu hỏi (qCode): r2m919ba].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getData với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một danh sách số nguyên (List<Integer>) từ server.
    Ví dụ: 7602,9136,1090,34319,7830,6179,10584,20166,28199,30250,32179,22544,3222,10320,30590,19279
b. Thực hiện tìm số lớn nhất có thể tạo dược từ a,b,c,d...
c. Triệu gọi phương thức submitDataString(String studentCode, String qCode, String data) để gửi kết quả tổng đã tính được trở lại server.
    Ví dụ: 91367830760261793431932223217930590302502819922544201661927910901058410320
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.List;
import vn.medianews.*;


public class TaoSoLonNha {
    public static void main(String[] args) {
        String studentCode = "B21DCCN478";
        String qCode = "r2m919ba";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        
        List<Integer> list = port.getData(studentCode, qCode);
        System.out.println(list);
        
        String largestNumber = null;
        List<String> stringNumbers = new ArrayList<>();
        for (int i : list) {
            stringNumbers.add(String.valueOf(i));
        }
        stringNumbers.sort((a, b) -> (b + a).compareTo(a + b));
        largestNumber = String.join("", stringNumbers);
        System.out.println(largestNumber);
        
        port.submitDataString(studentCode, qCode, largestNumber);
    }
}


Làm sạch và đảo ngược chuỗi - CharacterService
[Mã câu hỏi (qCode): 7jNPY5Nz].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestString với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một chuỗi (String) từ server. Chuỗi có thể chứa các ký tự đặc biệt và khoảng trắng.
b. Tạo một chuỗi mới từ chuỗi nhận được bằng cách:
•        Loại bỏ tất cả các ký tự đặc biệt, số, chỉ các ký tự chữ cái.
•        Đảo ngược chuỗi kết quả sau khi đã loại bỏ các ký tự đặc biệt.
c. Triệu gọi phương thức submitCharacterString(String studentCode, String qCode, String cleanedAndReversedString) để gửi chuỗi đã được làm sạch và đảo ngược trở lại server.
Ví dụ: Nếu chuỗi nhận được từ phương thức requestString là "hello@ world! 2024", sau khi loại bỏ các ký tự đặc biệt sẽ thành "helloworld", và khi đảo ngược sẽ là "dlrowolleh". Chuỗi kết quả "dlrowolleh" sẽ được gửi lại server qua phương thức submitCharacterString.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
*/
import vn.medianews.*;


public class LamSachVaDaoNguocChuoi {
    public static void main(String[] args) {
        String studentCode = "B21DCCN478";
        String qCode = "7jNPY5Nz";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        
        String receivedString = port.requestString(studentCode, qCode);
        System.out.println(receivedString);
        
        StringBuilder newString = new StringBuilder();
        for (char c : receivedString.toCharArray()) {
            if (Character.isLetter(c)) newString.append(c);
        }
        newString.reverse();
        
        port.submitCharacterString(studentCode, qCode, newString.toString());
    }
}


Phân số tối giản - DataService
[Mã câu hỏi (qCode): poApcyrJ].  Một dịch vụ web được định nghĩa và mô tả trong tệp DataService?wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/DataService?wsdl để xử lý các bài toán với dữ liệu nguyên thủy.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với DataService thực hiện các công việc sau:
a. Triệu gọi phương thức getDataDouble với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một số thập phân (double) từ server.
b. Làm tròn số thập phân nhận được tới 02 chữ số thập phân và thực hiện chuyển đổi số thập phân nhận được thành một phân số tối giản. Lưu tử số và mẫu số nguyên của phân số đó vào danh sách (List<Integer>) với phần tử đầu tiên là tử số và phần tử thứ hai là mẫu số.
c. Triệu gọi phương thức submitDataIntArray(String studentCode, String qCode, List<Integer> data) để gửi phân số đơn giản nhất đã chuyển đổi trở lại server.
Ví dụ: Nếu số thập phân nhận được từ phương thức getData là 0.75, chương trình client sẽ chuyển đổi thành phân số tối giản là [3, 4], và gửi mảng [3, 4] trở lại server qua phương thức submitData.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.List;
import vn.medianews.*;


public class PhanSoToiGian {
    public static int gcd(int a, int b) {
        if (b == 0) return  a;
        else return gcd(b, a % b);
    }
    public static void main(String[] args) {
        String studentCode = "B21DCCN505";
        String qCode = "poApcyrJ";
        
        DataService_Service service = new DataService_Service();
        DataService port = service.getDataServicePort();
        double receivedData = port.getDataDouble(studentCode, qCode);
        System.out.println(receivedData);
        double roundedValue = Math.round(receivedData * 100.0) / 100.0;
        int numerator = (int) (roundedValue * 100);
        int denominator = 100;
        int gcd = gcd(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
        
        System.out.println(numerator);
        System.out.println(denominator);
        
        List<Integer> fraction = new ArrayList<>();
        fraction.add(numerator);
        fraction.add(denominator);
        
        port.submitDataIntArray(studentCode, qCode, fraction);
    }
}


Chuyển đổi chuỗi sang ba định dạng: PascalCase, camelCase, snake_case - CharacterService
[Mã câu hỏi (qCode): vhcW4uck].  Một dịch vụ web được định nghĩa và mô tả trong tệp CharacterService.wsdl, được triển khai trên server tại URL http://<Exam_IP>:8080/JNPWS/CharacterService?wsdl để xử lý các bài toán về chuỗi và ký tự.
Yêu cầu: Viết chương trình tại máy trạm (WS client) để giao tiếp với CharacterService thực hiện các công việc sau:
a. Triệu gọi phương thức requestString với tham số đầu vào là mã sinh viên (studentCode) và mã câu hỏi (qCode) để nhận về một chuỗi (String) từ server. Chuỗi có thể chứa các từ được phân tách bằng dấu cách hoặc dấu gạch dưới.
b. Chuyển đổi chuỗi đã nhận được sang ba định dạng khác nhau:
•        PascalCase: Mỗi từ bắt đầu bằng chữ in hoa, không có khoảng cách giữa các từ.
•        camelCase: Từ đầu tiên viết thường, các từ tiếp theo viết hoa chữ cái đầu và viết liền nhau.
•        snake_case: Các từ được viết thường và nối với nhau bằng dấu gạch dưới.
c. Triệu gọi phương thức submitCharacterStringArray(String studentCode, String qCode, List<String> data) để gửi mảng kết quả chứa ba chuỗi đã định dạng trở lại server, theo thứ tự: PascalCase, camelCase, snake_case.
Ví dụ: Nếu chuỗi nhận được từ phương thức requestCharacter là "hello world example", các chuỗi kết quả sẽ là:
•        PascalCase: "HelloWorldExample"
•        camelCase: "helloWorldExample"
•        snake_case: "hello_world_example"
Mảng kết quả sẽ là ["HelloWorldExample", "helloWorldExample", "hello_world_example"], và sẽ được gửi lại server qua phương thức submitCharacter.
d. Kết thúc chương trình client.


Code:


package WS;


/**
 *
 * @author Nauh
 */
import java.util.ArrayList;
import java.util.List;
import vn.medianews.*;


public class ChuyenSang3DinhDang {
    public static void main(String[] args) {
        String studentCode = "B21DCCN289";
        String qCode = "vhcW4uck";
        
        CharacterService_Service service = new CharacterService_Service();
        CharacterService port = service.getCharacterServicePort();
        String receivedString= port.requestString(studentCode, qCode);
        System.out.println(receivedString);
        List<String> res = new ArrayList<>();
        res.add(toPascalCase(receivedString));
        res.add(toCamelCase(receivedString));
        res.add(toSnakeCase(receivedString));
        
        port.submitCharacterStringArray(studentCode, qCode, res);
    }


    private static String toPascalCase(String receivedString) {
        String[] words = receivedString.split("[ _]+");
        StringBuilder pascalCase = new StringBuilder();
        for (String word : words) {
            pascalCase.append(Character.toUpperCase(word.charAt(0))).append(word.substring(1).toLowerCase());
        }
        return pascalCase.toString();
    }
    private static String toCamelCase(String receivedString) {
        String pascalCase = toPascalCase(receivedString);
        return Character.toLowerCase(pascalCase.charAt(0)) + pascalCase.substring(1);
    }
    private static String toSnakeCase(String receivedString) {
        String[] words = receivedString.split("[ _]+");
        StringBuilder snakeCase = new StringBuilder();
        for (int i = 0; i < words.length; i++) {
            if (i > 0) snakeCase.append("_");
            snakeCase.append(words[i].toLowerCase());
        }
        return snakeCase.toString();
    }
}